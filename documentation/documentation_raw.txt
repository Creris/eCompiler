1. Basics
    1.1 vJass Construct
        vJass Construct is everything that can be specified in vJass syntax.
        Example:
            function a takes nothing returns nothing
                ...
            endfunction
            
            struct A
                ...
            endstruct
            
        All names are case sensitive.
        
    1.2 Keyword
        Keyword is every sequence of characters that is reserved for implementation.
        Some keywords can be context-sensitive, other can be reserved for future use, rather than being currently used.
        
        1.2.1 Keyword List
            The following is the list of keywords reserved to the compiler:
            
                debug
                native
                library
                endlibrary
                uses
                requires
                needs
                initializer
                optional
                scope
                endscope
                globals
                endglobals
                struct
                endstruct
                extends
                type
                function
                endfunction
                takes
                returns
                return
                method
                endmethod
                operator
                static
                private
                public
                readonly
                constant
                temporary
                local
                template
                alias
                inline[1]
                deprecated[1]
                textmacro
				runtextmacro
                endtextmacro
                module
                endmodule
                external
                endexternal
                externalblock
                endexternalblock
                interface
                endinterface
                stub
                defaults
                sizeof
                static_assert
                compiletime
                while
                endwhile
                loop
                exitwhen
                break
                endloop
                for
                endfor
                implement
                if
                then
                elseif
                else
                endif
                and
                not
                or
                catch
                call
                set
                thistype
                final[1]
                #if
                #elseif
                #else
                #endif
                auto
                override
                mutable
                endblock
                allocator
                endallocator
                using
                hook
                before[1]
                after[1]
                constructor
                endconstructor
                destructor
                enddestructor
                construct
                import
                encrypted
				priority
				extendor
				endextendor
                
            [1]: Context-sensitive keywords, that can be found elsewhere in the script as valid names and are treated as keywords
                 only when used in given context.
    
    1.3 Scope
        Scope is everything that directly splits code to sections.
        
        Example:
        
            library L
                //Scope L
                Scope Q
                    //Scope L.Q
                    function f takes nothing returns nothing
                        //Scope L.Q.f
                        if true then
							//Scope L.Q.f.if_1
                        endif
                    endfunction
                    //Scope L.Q
                endscope
                //Scope L
            endlibrary
            //Scope Global
            function a takes nothing returns nothing
                //Scope a(same as Scope Global.a)
            endfunction
        
        Special Scope is the Global Scope, which contains everything in given Map Script.
        
        Special names:
            1. Defining Scope
                Is the Scope that defines given vJass construct.
                If, for instance, function defines local variable, then the defining Scope
                is the function defining the local variable.
            
            2. External Scope
                Is every Scope, other than Scope of given context(for instance, Defining Scope)
		
		1.3.1 Global Scope
			Global Scope is the outer-most Scope of the map script, which is not inside any other Scope and all other scopes
			are inside that Scope.
			All name-referable vJass constructs are reachable from Global Scope.
			
			1.3.1.1 Global
				Special modifier Global can be used as part of name of name-referable vJass construct to
				specify that the Scope resolution(See 1.3.2 - Scope resolution) happens from the Global Scope.
		
		1.3.2 Scope resolution
			Scope resolution in vJass is performed by using the dot syntax for Scope names.
			
			1.3.2.1 Scope resolution rules
				When looking for names on name-referable vJass constructs, the compiler will take these rules into consideration:
				
				1. Global Scope is visible and accessible from any other Scope
				2. For any given Scope all its parent Scopes are implicitly declared and considered in Scope resolution and their parts of
				   full path for given vJass construct can be omitted
				3. All other Scopes are External for given point of map script, and to be usable, they must be accessed by their full path
				
				Example:
				
				library A
					function f takes nothing returns nothing
					endfunction
					
					scope S
						function q takes nothing returns nothing
							call f()		//same as call A.f() or Global.A.f()
						endfunction
					endscope
					
					function w takes nothing returns nothing
						call q()			//compilation error: q is undeclared from this scope
						call S.q()			//fine, will call A.S.q
					endfunction
				endlibrary
			
			1.3.2.2 using
				To explicitly declare External Scope as implicit, the keyword using can be used inside any scope
				to declare that scope as implicit for Scope resolution.
				
				Keyword using can only be used on Scopes that are created by scope or library keywords.
				
				If using is used and the Scope using is tried to make implicit is not found from that point in map script, a error is issued.
				
				Example:
					library A
						using S		//compilation error: No scope S found
						
						scope S
							function f takes nothing returns nothing
							endfunction
							
							scope Q
								function w takes nothing returns nothing
								endfunction
							endscope
						endscope
						
						using S
						using S.Q
						
						function q takes nothing returns nothing
							call f()
							call w()
						endfunction
					endlibrary
				
				1.3.2.2.1 White spaces
					using scope_name
					
					1. keyword using and scope_name are bound tightly into each other
		
		1.3.3 Shadowing
			If there exists name-referable vJass construct called g inside Scope S, and this Scope contains another Scope W which also
			contains name-referable vJass construct called g, the Scope W will shadow name-referable vJass construct g from beginning of g's definition
			until the end of scope W. (Case 1)
			
			If there exists name-referable vJass construct called g inside Scope S, and this Scope contains another Scope W which also
			contains name-referable vJass construct called g, and there exists Scope Q which has both Scope S and Scope W in its list of implicit
			Scopes, Scope Q will have ambiguous reference to g and error will be issued. (Case 2)
			
			Example:
				scope S
					function f takes nothing returns nothing
					endfunction
					
					scope Q
						function f takes nothing returns nothing
							call f()		//will call S.Q.f
											//Case 1
						endfunction
						
						function w takes nothing returns nothing
							call f()		//will call S.Q.f
											//Case 1
						endfunction
					endscope
					
					function w takes nothing returns nothing
						call f()			//will call S.f
											//Case 1
					endfunction
				endscope
				
				scope W
					using S
					using Q		//same as using S.Q at this point
					
					//Error: function f() defined multiple times
					
					function r takes nothing returns nothing
						call f()			//Error: Could not resolve call to f()
											//Could be: S.f, S.Q.f
											//Case 2
					endfunction
					
					function f takes nothing returns nothing
											//Error: function f() defined multiple times
					endfunction
				endscope
        
        1.3.4 Bracket-scoping
            Brackets can also create pseudo scopes for certain Syntactic Units(see 1.12 - Syntactic Unit).
            
            The lowest bracket-scope is the lowest, and the more opening brackets are encountered, the higher bracket-scope is.
            
            Example:
                A(B((C(D)E)F)G)Q
                
                A is in bracket-scope 0
                B is in bracket-scope 1
                C is in bracket-scope 3
                D is in bracket-scope 4
                E is in bracket-scope 3
                F is in bracket-scope 2
                G is in bracket-scope 1
                Q is in bracket-scope 0
            
    1.4 Qualifiers
        Qualifiers are vJass Constructs that can be placed before any other vJass Constructs.
        
        1.4.1 Visibility-Qualifier
            Visibility-Qualifier distinguishes whether given vJass Construct is visible
            to the whole script, or if only the local scope can access and use it.
            
            Abbreviation: Vis-Qualifier.
            
            Valid Vis-Qualifiers:
                                    public
                                    private
                                    --none--
            
            In case Visibility-Qualifier is required or optional, and none is provided, the vJass Construct
            is automatically marked with Public Visibility-Qualifier.
            
        1.4.2 Staticity-Qualifier
            Staticity-Qualifier determinates whether given vJass Construct is usable
            only for one instance of struct/interface, or if it is usable by all instances.
            
            Abbreviation: Static-Qualifier.
            
            Valid Static-Qualifiers:
                                        static
                                        --none--
                                        
            In case Staticity-Qualifier is required or optional, and none is provided, the vJass Construct
            is automatically marked with Nonstatic Staticity-Qualifier.
            
        1.4.3 Readonly-Qualifier
            Readonly-Qualifier determinates whether given vJass Construct is only readable from
            scopes other than defining scope, or if it is possible to also write to such vJass Construct
            from external scopes.
            
            Valid Readonly-Qualifiers:
                                        readonly
                                        --none--
            
            In case Readonly-Qualifier is required or optional, and none is provided, the vJass Construct
            is automatically marked with nonreadonly Readonly-Qualifier.
        
        1.4.4 Const-Qualifier
            Const-Qualifier determinates whether given vJass Construct is constant(unmodifiable), or
            if it can be modified after definition or declaration.
            
            Const-Qualifier before function definition have special meaning.
            
            Valid Const-Qualifiers:
                                    constant
                                    --none--
                                    
            In case Const-Qualifier is required or optional, and none is provided, the vJass Construct
            is automatically marked with nonconstant Const-Qualifier.
		
		1.4.5 Comp-Qualifier
			Comp-Qualifier determinates whether given vJass construct can be marked as compiletime, meaning that it can
			be executed by interpreter during compilation of the map script.
			
			Valid Comp-Qualifiers:
                                    compiletime
                                    --none--
			
			In case Comp-Qualifier is required or optional, but none is provided, the vJass Construct is automaticallz marked
			with noncompiletime Comp-Qualifier.
    
    1.5 Literals
        Literals are raw values for basic in-built types(See 2.2 - Basic Types).
        
        1.5.1 Integer Literal
            1.5.1.1 Decimal
                Decimal Integer literal describes given integer in decimal format.
                
                Decimal literals must never start with 0.
                Valid characters, that can occur in decimal representation are 0123456789.
                
                Exmple:
                    54677
                    
            1.5.1.2 Octal
                Octal Integer literal describes given integer in octal format.
                
                Octal Integer literals must always start with 0.
                Valid characters, that can occur in octal representation are 01234567.
                
                Example:
                    055
                    071
            
            1.5.1.3 Hexadecimal
                Hexadecimal Integer literal describes given integer in hexadecimal format.
                
                Hexadecimal Integer literals must always start with 0x, or 0X.
                Valid characters, that can occur in hexadecimal representation are
                0123456789abcdefABCDEF.
                
                Example:
                    0x77
                    0X7A
                    0x7a
                    0X7A
            
            1.5.1.4 256-base
                256-base literal describes given integer in special, base 256 format.
                
                256-base integer literals can be represented by either 1, or 4 characters, enclosed
                in pair of ampersands(').
                
                1.5.1.4.1 One character Literals
                    One character literals can be represented by the following characters
                    0123456789`~!@#$%^&*()_+-=[]{};:"|,\./&lt;&gt;?abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
                    
                    Additionally, One character literals can also be represented by '\n' or '\t' as well as physical
                    tab or space.(\t == "tab"), as well as '\\'
                    
                    Example:
                        '    '
                        '5'
                    
                1.5.1.4.2 Four character literals
                    Four character literals can be represented by the following characters
                    0123456789`~!@#$%^&*()_+-=[]{};:"|,./&lt;&gt;?abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
                    
                    Additionally, Four character literals can also be represented by physical tab or space.
                    
                    Example:
                        'ABCD'
                        '5`0]'
                        '    5w2'

        1.5.2 Real literals
            Example:
                1.
                1.1
                0.1
                .1
                3.14159
                
        1.5.3 Boolean Literal
            Boolean literal represents logical values.
            Only available literals are true and false.
            
        1.5.4 String Literal
            String literal is such sequence of characters, that is enclosed in between quotation marks(").
            Maximal length of String literal is 1023 characters long.
            
            String literal can also contain tab, space and newline characters.
            
            Special characters that must be pre-placed with backslash(\) to be valid:
                \n - new line
                \t - tab
                \" - quotation mark
                \\ - backslash
            
            Example:
                nonStringLiteral"String Literal"
                "Also
                String literal"
        
        1.5.5 Code Literal
            Code literal represents a user-defined function, that is addressed by it.
            Code literal can address any function that takes nothing. Return type does not play.
            
            To form Code literal, the name of function must be prefixed with function keyword.
            
            Example:
                function f
                function myComplicatedFunction
                
            To address static method, user must prefix the name with the struct's name.
            
            Example:
                function MyStructType.myMethod
                function thistype.myMethod
            
            1.5.5.1 Advanced Code Literal
                Advanced Code literal allows user to address function that has arguments.
                
                To address such literal, user must specify which function to address.
                
                Example:
                    function myF(integer)
                    function incredibleFunc(real, string, unit)
                    function MyStructType.myMemberFunc(real, real)
                
                Additionally, user can address nonstatic member function, by writing `this` as first argument.
                
                Example:
                    function myNonstaticMemberFunction(this, integer)
                
                It is possible to pass in intermediate values of variables, or literals into function addressed
                using Advanced Code Literal addressing.
                
                Example:
                    function myF(integer)(5)
                    function myF(unit)(someVariable)
                
                1.5.5.1.1 Advanced code literal as function argument
                    For functions, see 4. - Function.
                    
                    Functions can take advanced code literals as their arguments.
                    
                    Type of any advanced code literal is:
                        opt:(Const-Qualifier) function(opt:(type_list)) opt:(return_type)
                    
                    Example:
                        constant function(integer, integer, real, string) real
                        function(integer)
                    
                    If no return_type is provided, function can have any return type.
                    If Const-Qualifier is not provided, function passed can be constant or normal.
                    If Const-Qualifier is provided, function passed must be constant.
    
    1.6 Expression
        Expression is everything that can be stored within callable vJass construct(see 4. - Function, see 8.3 - Method).
        
        Expressions include(but are not limited to) assignments, function calls, control flow blocks and return statements.
        
        Expressions are always evaluated from left to right, meaning that following code:
            call A(B(), C(D()), E())
        will proceed in following order:
            1. call B()
            2. call D()
            3. call C()
            4. call E()
            5. call A()
            
        1.6.1 Expression levels
            Every expression can be assigned value representing the depth. This value is called level.
            
            Top-level expressions are such expressions that are not encapsulated in another expressions.
            Every expression that is encapsulated in N expressions is of Nth-level expression.
            
            Expressions can be any level deep.
        
    1.7 Comments
        Comments serve to split code, and make it more readable, and potentially add notes to code.
        
        1.7.1 Single line comments
            Single line comments are comments that only allow commenting out text in one line,
            from the beginning of the comment up to new line character.
            
            1.7.1.1 Syntax
                // - Marks the beginning of Single line comment.
                
                Example:
                    noncomment//comment
                
                Notes:
                    Beginning of Single line comments found within String literals are
                    never treated as beginnings of comment lines.
                    
        1.7.2 Multiple line comment
            Multiple line comments are comments that allow user to split their code
            intelligently.
            
            1.7.2.1 Syntax
                /* - marks the beginning of Multiple line comment
                */ - marks the end of Multiple line comment
                
                Example:
                    nonComment/*Comment/*StillComment*/StillComment
                    Still Comment*/ not comment anymore
                
                Notes:
                    Multiple line comments can be nested indefinitely.
                    Beginning and endings of Multiple line comments found within String literals are
                    never treated as beginnings and endings(respectively) of Multiple comment lines.
                    
    1.8 Constness
        Constant objects are such objects that can not be modified or can not modify the environment.
        
        1.8.1 Constant
            1.8.1.1 Constant Function behaviour
                Constant functions(see 4. - Function) are such functions, that can not modify the arguments passed to them
                and can also not modify any global variable.
                
                Some native functions are not marked as constant but do not modify state of taken variables(Geters, Isers),
                and these functions are treated as constant.
            
            1.8.1.2 Constant Function argument
                Constant function argument(see 4. - Function) is such argument, that can not be modified when passed
                into function. Nonconstant variables may be passed into function expecting constant arguments.
                
            1.8.1.3 Constant variable
                Constant variable is such variable that can only be assigned to when defined.
                Constant variable can be passed into function's non-constant argument, if the variable is
                of copyable type(see 2.2.1 - Copyable Types).
                
            1.8.1.4 Constant value
                Constant value is any literal to Basic Type, Constant expression(see 1.9.4 - Compiletime Expression evaluation) or
                Constant variable.
            
            1.8.1.5 Function returning constant variable
                Function(see 4. - Function) can return constant variable, meaning it can not be modified and can only be stored
                in another constant variable; or can be passed as nonconstant argument, or stored in nonconstant variable
                if the return type is copyable(see 2.2.1 - Copyable Type).
                
        1.8.2 Compiletime
            1.8.2.1 Compiletime function behaviour
                Compiletime function(See 4. - Function) is such function, that can be called in compiletime environment,
                such as inside static if block, or from other compiletime function.
                
                Additionally, all arguments of such function must also be compiletime values and the return value is also
                compiletime.
                
                Compiletime function must have all paths in its body evaluable in compiletime.
                This means that there may only be if(see 5.2 - Compile time conditional block) or a loop of any sort with compiletime
                deducible number of iterations, or compiletime deducible exitwhen condition, or static if.
                
                Additionally, the function must return the same value at all times in one branch and therefore the return
                type may only be dependable on compiletime conditions.
                
                Function marked as compiletime can be executed in both compiletime and runtime environment.
                If compiletime function is never used in runtime environment, the function is not generated in the resulting output.
                
                Function is also considered compiletime if all of its arguments are compiletime and its return type is also marked
                as compiletime.
                
                Static method inside struct can also be declared as compiletime. It may, however, not access any nonstatic variables
                of any struct.
                
            1.8.2.2 Compiletime function arguments
                Function's arguments can also be specified as compiletime explicitly, and don't require whole function
                to be compiletime.
                
                Such variable can only be initialized to value deducible in compiletime, so return value of compiletime
                function, or function with compiletime return value, or literal.
                
            1.8.2.3 Compiletime variable
                Compiletime variable is such variable that can have its content read while script is compiling.
                
                Both global and local variables can be compiletime.
                Global compiletime variables can be initialized to literals of Basic Types, compiletime
                expression(see 1.9.4 - Compiletime Expression evaluation) or to compiletime value returned from Compiler method,
                or from user-defined function.
                
                Local compiletime variables can be initialized to literals of Basic Types, compiletime
                expression(see 1.9.4 - Compiletime Expression evaluation) or to compiletime value returned from
                Compiler method, or from user-defined function.
            
            1.8.2.4 Compiletime value
                Compiletime value is any literal to Basic Type, compietime expression(see 1.9.4 - Compiletime Expression evaluation)
                or compiletime variable.
                
            1.8.2.5 Function returning compiletime variable
                Function can mark its return value as compiletime.
                
				Such function must return a compiletime deducible value on all paths of execution.
                
                Function with compiletime return value can only be used in in compiletime environment if all of its arguments are
                marked as compiletime as well, or if the whole function is marked as compiletime, or the function has no arguments.
			
			1.8.2.6 Compiletime struct
				Any user-defined object(struct) can be declared as compiletime, and can then be used in compiletime environment.
				All members of given struct(methods and variables) are implicitly declared as compiletime as well.
        
    1.9 Optimizations
        Various optimizations are done on the resulting map script after compilation.
        
        1.9.1 Name Shortening
            Every variable and function name is shortened to the shortest length possible, saving both file size
            and speed(thanks to nature of Jass Virtual Machine).
            
            The names start go in following pattern:
                a - z, A - Z, a0 - a9, b0 - b9, ..., z0 - z9, A0 - A9...
            
            Special name sequences may be reserved for special uses.
            
        1.9.2 Function Inlining
            Functions that are marked with 'inline' are requested to be inlined, and will be inlined under
            certain conditions(see 4.1.1 - Inlining Rules).
            Short functions that are not marked as 'inline' will also be inlined if the above conditions hold true for them too.
            
        1.9.3 Constant/Compiletime variable inlining
            Every compiletime and constant variable is inlined, if Optimization for speed is required.
            Otherwise all compiletime and constant variables are only optimized if their respective values take less space
            then the variables themselves.
            
        1.9.4 Compiletime Expressions evaluation
            If there are expressions have compile-time deducible value( Sin(3.0), Pow(2.0, 5.), (3 * (2 + 5)) ), then the expressions
            are evaluated to the corresponding numbers(0.05233596, 32. and 21 respectively).

        1.9.5 Dead code removal
            Every callable vJass construct or Expression that is not called, or referenced(taken address of) anywhere in code is
            automatically removed.
            Every unnecessary white space, as well as all delimited and normal comments are automatically removed.
            Every expression after return statement until end of nearest Scope is automatically removed.
            Every unreferenced variable is automatically removed.
        
        1.9.6 As-If rule
            Compiler can do anything to the code, as long as the resulting behaviour of the code does not change from the original
            intended behaviour of script.
            
            This means that JassHelper can for instance remove functions, even when called or referenced from trigger, timer,
            boolexpr or other Build-in type, if the function does not modify any visible state(For instance only defines
            local variable and sets it to some literal).
            
            If by this action timer is removed, and the function has no side effects but destroying the timer, the function
            can still be omitted.
            
            Note: Declaring and initializing local variable with either literal or return value of constant function,
            or calling constant function has no side effects.
        
    1.10 Deprecated
        Keyword deprecated marks that given callable vJass construct(such as function[see 4. - Function] or method[see 8.3 - Method])
        is old and should no longer be used.
        
        If callable vJass construct is marked with deprecated, the compilation will stop with error in Debug mode when such
        function is called, suggesting 'text', or pops warning in Release mode.
        
        1.10.1 Syntax
            deprecated opt:[(string message opt:(, replacement_function_name))]
            
            If no message is provided, or empty string("") is passed, a "deprecated function call attempt" error or warning is popped.
            Otherwise, the format is always: 'called_func_name message'.
                                             
            User can also pass a function name as second argument into deprecated, hinting which function should be called instead.
            The function name must be valid function name visible to the deprecating function as well as the caller in the map script,
            or name of native function, or name of Blizzard defined function.
            
            Function referenced in deprecated keyword does not need to have the same signature or return type
            as the deprecated function. If the function is of different signature, its signature is printed in the
            error/warning message.
            
            Example:
                deprecated("no longer supported") function myF takes nothing returns integer
                    return 5
                endfunction
                
                call myF()    //outputs: Error: function myF no longer supported
                
                deprecated function still_Legal_Function takes nothing returns nothing
                endfunction
                
                function foo takes integer i returns integer
                    return i + 1
                endfunction
                
                deprecated("outdated", foo) function bar takes nothing returns boolean
                    return false
                endfunction
                
                call bar()    //outputs: Error: function bar outdated.
                              //                Use function foo takes integer returns integer instead
            
                scope s
                    function f takes nothing returns integer
                        return 5
                    endfunction
                endscope
                
                deprecated("", s.f) function q takes nothing returns nothing
                endfunction
                
                scope Q
                    struct MyStruct
                        method a takes nothing returns nothing
                        endmethod
                        
                        static method w takes nothing returns nothing
                        endmethod
                        
                        deprecated("", thistype.w) method t takes nothing returns nothing
                            //Error: deprecated static method MyStruct.t call attempt
                            //       Use static method MyStruct.w instead
                        endmethod
                    endstruct
                endscope
                
                deprecated("don't use anymore!", Q.MyStruct.a) function QQ takes nothing returns nothing
                    //Error: function QQ don't use anymore!
                    //       Use method MyStruct.a instead
                endfunction
                
                deprecated("", MyStruct.a) function QW takes nothing returns nothing
                    //Error: deprecated function QW call attempt
                    //       Use method MyStruct.a instead
                endfunction
                
                deprecated("", MyStruct.w) function qqw takes nothing returns nothing
                    //Error: deprecated function qqw call attempt
                    //       Use static method MyStruct.w instead
                endfunction
    
    1.11 Operators
        1.11.1 Arithmetic operators
            Arithmetic operators perform arithmetic operations on operand or operands.
            
            1. +
            2. -
            3. /
            4. *
            5. +=
            6. -=
            7. /=
            8. *=
            9. ++
            10. --
            11. % 
            12. %=
            13. <<
            14. >>
            15. <<=
            16. >>=
            
            None of operators accept non-implicitly convertible types as their operands.
            Operators 9, 10, 11, 12, 13, 14, 15 and 16 only accept integer variables.
        
        1.11.2 Logical operators
            Logical operators perform logical operations on operand or operands.
            
            1. ==
            2. <=
            3. >=
            4. !=
            5. !
            6. not
            7. and
            8. or
            
            Operators ==, <=, != and >= can accept any implicitly convertible types,
            and can also accept any mix of integers and reals.
            Operators 5, 6, 7 and 8 only accept boolean values(unless overloaded).
            
			Additional operations on operators can be found on Operator Overloading.
        
        1.11.3 Operator precedence
            The following is list of precedences of operators in descending order(highest precedence to lowest):
                    Name                                    Symbolic representation
                1. Parenthesis                                       ()
                2. unary increment/decrement                         X++, ++X, X--, --X
                3. bracket operator                                  X[Y]
                4. dot operator                                      X.Y
                5. not operator                                      not A, !A
                6. multiplication, division operator                 X * Y, X / Y
                7. addition, subtraction operator                    X + Y, X - Y
                8. bit shift operator                                X << Y, X >> Y
                9. boolean operators                                X < Y, X <= Y, X > Y, X >= Y, X == Y, X != Y
                10. and, or operators                                X and Y, X or Y
                11. Assignment operators                             X = Y, X += Y, X -= Y, X *= Y, X /= Y,
                                                                     X %= Y, X <<= Y, X >>= Y
                12. Comma operator                                   X, Y
                
    1.12 Syntactic Unit
        Syntactic unit is every non-white space character inside map script, be it name, keyword or parenthesis.
        
    1.13 White spaces - General
        Every Syntactic Unit(see 1.12 - Syntactic Unit) must be separated by at least one white space.
        
        For example, there must always be space between function and its name, and its name and takes.
        
        If two Syntactical Units can not be separated by new line, they are bound tightly.
        If two Syntactical Units can be separated by new line, they are bound loosely.
    
    1.14 Initialization rules
        Various functions can be marked as initiators which makes them run when the map is loaded.
        
        Initialization goes in this specified order:
            1. Library(see 7. - Library) initializers in following order:
                1.1 Library's initializer
                1.2 Initializer of every scope inside such library, which also follow 2.
                1.3 Initializers of modules implemented inside every struct inside such library
                1.4 Initializer of every struct inside such library
                1.5 Free-standing initializer
            
            2. Scope(see 6. - Scope) initializers in following order:
                2.1 Scope's initializers
                2.2 Initializer of every scope inside such scope, which also follow 2.
                2.3 Initializers of modules implemented inside every struct inside such scope
                2.4 Initializer of every struct inside such library
                2.5 Free-standing initializer
            
            3. Struct(see 8. - Struct) initializers in following order:
                2.1 Initializers of modules implemented by the struct
                2.2 Struct's initializer
                
            4. Free-standing Initializer(See 4.5 - Initializer function)
    
    1.15 Name-Referable Construct
        Name-Referable Construct is such vJass Construct, that can be referenced by name from script.
        
        Name-Referable Constructs are:
            1. Type names
            2. Variable names
            3. Function names
            4. Struct names
            5. Method names
	
	1.16 Debug
		Debug mode can be represented by global variable DEBUG_MODE(set to true when compiling in debug mode) or with keyword
		debug.
		
		1.16.1 DEBUG_MODE and RELEASE_MODE
			JassHelper defines 2 compile-time global boolean variables usable anywhere in the script called DEBUG_MODE and RELEASE_MODE.
			When compiling in debug mode, DEBUG_MODE is set to true and RELEASE_MODE is set to false.
			When compiling in release mode, RELEASE_MODE is set to true and DEBUG_MODE is set to false.
		
		1.16.2 debug keyword
			When any Syntactic Unit is pre-placed with debug keyword, given Syntactic Unit will only be generated when
			JassHelper is compiling the map script in Debug mode.
			
			Example:
				debug function f takes nothing returns string
					debug local string s = "Some String literal"
					debug return s
				debug endfunction
				
				function w takes nothing returns nothing
					local string toPrint = "TPr"
					debug if SomeFunction() then
						debug call BJDebugMsg(Compiler.nameOf(SomeFunction) + " returned true! RUN AWAY!")
					debug else
						call BJDebugMsg(toPrint)
					debug endif
				endfunction
			
			Function f as well as its contents will only be generated when JassHelper compiles in Debug mode.
			When calling function w, it will create local string and initialize it to string literal "TPr".
			Then, if JassHelper is compiling in debug mode, then SomeFunction will be called, and if it returns true
			then it will print that the function returns true. If it returns false, it will output contents of the string.
			If JassHelper is compiling in Release mode, it will only output the contents of the string, even though it is defined inside
			else branch of the if, because the whole if block is removed from the resulting script.

	1.17 Priorities
		Priority defines when should given vJass Construct be executed/evaluated or in other means ran.
		
		1.17.1 Syntax
			priority=[compile-time integer]
			
			Example:
				priority=54
				priority=-200
			
			If vJass construct has optional priority, and none is provided, implicit priority of 0 is assumed.
			
			Priorities can have range from -2,147,483,648 to 2,147,483,647.
			
			Special Priorities are "Lowest, Highest".
			priority=Highest requires given vJass Construct to be ran before any other same vJass Construct.
			priority=Lowest requires given vJass Construct to be ran after any other same vJass Construct.
			
			If 2 same vJass Constructs are defined with the same priority, they are ran in order of appearance of these vJass Constructs
			to the parser.
			
			1.17.1.1 White spaces
				priority=[compile-time integer]
				
				1. priority keyword is bound tightly into following =.
				2. = is bound tightly into [compile-time integer].
	
	1.18 Static_assert
		While compiling, when JassHelper encounters static_assert, it will stop compilation with error message if certain condition
		evaluates to true.
		
		1.18.1 Syntax
			static_assert(condition opt:[, error_string])
			
			Example:
				static_assert(integer == real, "Internal JassHelper error")
				
			If condition, which must be compile-time condition, inside static_assert evaluates to true, a compilation is immediately stopped with error.
			If error_string is provided, it is output with the error message.
			
			1.18.1.1 White spaces
				See 4.2.2 - Function Calling

	1.19 preprocessor
		Preprocessor is part of the compiler that runs over the map script before the script is parsed and validated, optimized and converted into Jass.
		
		Preprocessor directives are: #if, textmacro, extendor, import, external.
		
		Preprocessor does 2 passes over the map script.
		In first pass, the preprocessor will import all code that import preprocessor directive requested and remove these directives as well as parse external blocks.
		In second pass, the preprocessor handles the rest(static ifs, textmacros, extendors).
		
		The preprocessor starts at the top of the map script, and parses the map script. If preprocessor finds library definition, it will jump
		into the libraries that this library requires/uses/needs before parsing that library.
		
		If preprocessor hits external with before as ExecMode, it will comment out this external block and after passing through the map script,
		it will attempt running the external tools with given input. After that, the map script starts parsing again.
		If preprocessor hits external with after as ExecMode, it will comment it out, continue compiling the map, and after JassHelper compiled the map it executes the external tools.
		
		If there is static if and it contains any other preprocessor directive other than import and external, these preprocessor directives will only be parsed if the static if condition evaluates into true.
		If there is import or external inside static if, it is parsed regardless of static if.
		
		Preprocessor holds state of currently defined vJass constructs for use in static if in combination with Compiler struct.

2. Type
    Type is a named vJass Construct that differentiates different variables by their meaning.
    
    2.1 Syntax
        type type_name opt:(extends type_name)
        
        Note: Users may not declare new types, and all types shall only be declared from within common.j or common.ai.
        
    2.2 Basic Types(Built-in types)
        Are types, that are elementary, and are not directly tight to the game logic.
        
        2.2.1 Integer
            Integer is representation of a whole number, with range from -2,147,483,648 to 2,147,483,647.
            
            Default operations on integers are possible, including +, -, *, /, <, >, <=, >=, ==, !=.
            
            Extra operations on integers are %, <<, >>, ++, --, +=, -=, *=, /=, %=, <<=, >>=.
            
            (v << n) multiplies the integer value by 2^n.
            (v >> n) divides the integer value by 2^n.
            (v % n) returns reminder of (v / n). This value is calculated as (v - (v / n) * n).
			v++ increments the stored value and returns it.
                
			v-- decrements the stored value and returns it.
            
			v++ and v-- can only be used with set keyword on one given variable, possibly array.
			Meaning that
			set v = v++ + v++
			set v = v++
			
			is malofrmed on both lines.
            
        2.2.2 Real
            Real literals represent numbers with decimal point.
            Range, as well as special values of Real literals is the same as IEEE 754 binary32.
            
            Default operations on reals are possible, including +, -, *, /, <, <=, >, >=, ==, !=.
            
            Extra operations on reals are +=, -=, *=, /=.
            
        2.2.3 Boolean
            Boolean represents either true, or false.
            
            Default operation on boolean is ==, !=, !, not, and, or.
        
        2.2.4 String
            Strings represent text in character-by-character form.
            
            Default operations on strings are +, ==, !=.
            
        2.2.5 Code
            Code represents address of user-defined function.
            
            Basic code variable can only address function that takes nothing and returns anything.
            
            2.2.5.1 Advanced Code
                Advanced code is extension to Code. It allows user to address functions that
                take any number of any parameters and also pass in immediate values of variables or literals
                into the functions.
                
        2.2.6 Handle
            Handle is special, complex type that is base for every other non basic type.
            Handle and built-in types derived from handle are not copyable and are a mere pointers to physical
            object lying in memory.
            
            2.2.6.1 Null
                null is special value, which represents nothing being stored in variable and can be used with
                any variable which derives from handle, handle or for string. It is implicitly convertible to any of these types.
        
        2.2.7 Nothing
            Nothing is a special type, that can not be instantiated, and is used to mark when function does not have any parameters,
            or when it does not return any value.
    
    2.3 Built-in Type
        Non Basic Type is such type, that is provided by Blizzard in common.j file. The number of Non Basic Types is dependant on version of common.j file.
        
        Examples of Non Basic Types are: unit, texttag, location, group, force, lightning and many more.
        
        Non basic types are not copyable, meaning that if function attempts to modify state of its argument, it will also modify state of
        passed value.
        
    2.4 User-Defined Type
        Users can't define types using type keyword.
        For User-defined Types definition, see 8. - Struct.
        
    2.5 Implementation reserved Types
        These types are reserved and/or used by the JassHelper.
        
		2.5.1 Special types
			Special types are types that are only visible to other reserved types, namely to Compiler struct.
			
			2.5.1.1 _rconstruct
				_rconstruct is a construct that marks raw vJass constructs, that can not be identified with keyword.
				
			2.5.1.2 _pconstruct
				_pconstruct is a vJass construct that is pre-placed with required vJass keyword to disambiguate the construct.
				
				Example: method m, library L, method L.W.w
			
			2.5.1.3 _type
				_type is a special type that means that argument is actual type.
			
			2.5.1.4 _callable_object
				_callable_object is any callable vJass object, namely: method, operator, function.
			
			2.5.1.5 _variable
				_variable marks that argument to function is specific variable, referred by its name in script.
				
        2.5.2 Compiler
            Compiler is special compiletime Struct(see 8. - Struct), that includes static methods to help users with
            compile-time requests. Compiler can not be instantiated by any means.
            
            2.5.2.1 Methods
                This is a list of methods that can be used in Compiler struct.
                
                2.5.2.1.1 static method getVersion takes nothing returns string
                    compiletime string equal to version of currently running JassHelper.
                    
                    Example:
                        BJDebugMsg(Compiler.getVersion())
                    
                    Output example:
                        "2.0.0"
                
                2.5.2.1.2 static method mainVersion takes nothing returns integer
                    compiletime integer representing the main version number(the first number)

                    Example:
                        BJDebugMsg(I2S(Compiler.mainVersion()))
                    
                    Output example:
                        2
                
                2.5.2.1.3 static method majorVersion takes nothing returns integer
                    compiletime integer representing the major version number(the second number)
                    
                    Example:
                        BJDebugMsg(I2S(Compiler.majorVersion()))
                        
                    Output example:
                        0
                        
                2.5.2.1.4 static method minorVersion takes nothing returns integer
                    compiletime integer representing the minor version number(the third number)
                
                    Example:
                        BJDebugMsg(I2S(Compiler.minorVersion()))
                        
                    Output example:
                        0
                    
                2.5.2.1.5 static method assert takes string assertation_message returns nothing
                    Immediately stops compilation of map script.
                    
                    Example:
                        Compiler.assert("#if ... evaluated to true!")
                    
                    Input:
                        assert requires compiletime string, which is printed to JassHelper output.
                
                2.5.2.1.6 static method exists takes _rconstruct c returns boolean
                    Checks whether given vJass construct exists or not.
                    
                    Example:
                        #if Compiler.exists(thistype.methodName) then
                        #endif
                    
                    Input:
                        Any vJass construct that is referable by name.
				
					2.5.2.1.6.1 static method existsS takes _pconstruct c returns boolean
						Checks whether given vJass construct with its type information exists or not.
						
						Example:
						#if Compiler.existsS(method thistype.methodName) then
						#endif
						
						Input:
							Any vJass construct that is referable by name.
                
                2.5.2.1.7 template <type T, type U> static method isSame takes T a, U b returns boolean
                    Returns whether T == U.
                    
                    This method is equal to following implementation:
                    
                    template <type T, type U>
                    compiletime static method isSame takes T a, U b returns boolean
                        return false
                    endmethod
                    
                    template <type T>
                    compiletime static method isSame takes T a, T b returns boolean
                        return true
                    endmethod
                
                2.5.2.1.8 static method nameOf takes _pconstruct c returns string
                    Returns a Jass string representing inner-most name of given vJass Construct.
                    
                    Example:
                        local string s = Compiler.nameOf(method thistype.myF)
                        call BJDebugMsg("going to call " + s)
                        call thistype.myF()
                    
                2.5.2.1.9 static method fullNameOf takes _pconstruct c returns string
                    Returns a Jass string representing complete name of given vJass Construct after optimizations.
                    If input construct is in Global Scope, the return value is exactly the same as nameOf.
                    
                    Example:
                        call ExecuteFunc(Compiler.fullNameOf(thistype.myStaticFunc))
                
                2.5.2.1.10 static method isParentOf takes _type a, _type b returns boolean
                    Returns whether type a is parent of b in inheritance table.
                    
                    Exmaple:
                        #if Compiler.isParentOf(handle, unit) then        //true
                            ...
                        #endif
						
						#if Compiler.isParentOf(handle, MyLibrary.MyAwesomeStruct) then
							...
						#endif
                    
                2.5.2.1.11 static method isDirectParentOf takes _type a, _type b returns boolean
                    Returns whether type a is direct parent of type b.
                    
                    Example:
                        #if Compiler.isDirectParentOf(handle, unit) then        //false, direct parent of unit is widget
                            ...
                        #endif
                    
                2.5.2.1.12 static method isChildOf takes _type a, _type b returns boolean
                    Returns whether a is child of b in inheritance table.
                    
                    Example:
                        #if Compiler.isChildOf(destructable, handle) then        //true
                            ...
                        #endif
                    
                2.5.2.1.13 static method isDirectChildOf takes type a, type b returns boolean
                    Returns whether a is direct child of b in inheritance table.
                    
                    Example:
                        #if Compiler.isDirectChildOf(destructable, handle) then        //false, because destructable is direct child of widget
                            ...
                        #endif
                    
                2.5.2.1.14 static method read takes string objectId, string fieldId, integer level = 0 returns string
                    Returns a fieldId for objectId from metadata files.
                    If such fieldId, or objectId does not exist, returns empty string.
					If such fieldId is requested, that does not depend on level, the level parameter is ignored, otherwise
					it is used to combine with the objectId and returns appropriate, level dependant value.
                    
                    Example:
                        compiletime local string paladinHp = Compiler.read("Hpal", "ihtp")    //paladinHp = "100"
						local string holyLightHeal = Compiler.read("AHhb", "Hhb1", 2)         //holyLightHeal = 400
                    
                2.5.2.1.15
                template <type T> requires T == integer or T == real or T == string
                static method read takes string objectId, string fieldId, integer level = 0 returns T
                    Reads a fieldId for objectId for metadata files.
                    if such fieldId or objectId does not exist, returns default-initialized value of type T.
                    
                    If type of returned value is not equal to T, returns default-initialized value of T.
                    Otherwise, returns a valid value.
					
					Other rules of non-templaded read also apply.
                    
                    2.5.2.1.15.1 static method readFailed takes nothing returns boolean
                        Returns whether the last call to 2.5.1.1.15 - static method read failed or not.
                    
                2.5.2.1.16 compilet method isTemplated takes _pconstruct t returns boolean
                    Returns whether construct t is templated or not.
                    
                2.5.2.1.17 static method inBuiltInType takes _type t returns boolean
                    Returns whether type t is built-in type or not.
                    
                2.5.2.1.18 static method isNativeType takes _type t returns boolean
                    Returns whether type t is native type or not.
                    This includes built-in types.
                    
                2.5.2.1.19 static method getOptimizationMode takes nothing returns integer
                    Returns 0 if /O0 is specified, otherwise returns 1.
                
                2.5.2.1.20 static method hasNetworkAccess takes nothing returns boolean
                    Returns whether JassHelper is allowed to connect to network or not.
                    
                2.5.2.1.21 template <type A> static method convert takes A v, _type B returns B
					Attempts to convert v of type A into type B.
					If conversion is successful, returns variable v cast into B, otherwise returns B()[default constructed B].
        
        2.5.3 FileState
            FileState is a compiletime type reserved for representing a state of CFile's operation(See 2.5.4 - CFile).
            FileState can be instantiated.
            
            2.5.3.1 Global variables
                JassHelper automatically creates 2 FileState global compiletime variables.
                
                2.5.3.1.1 compiletime FileState Ok
                    FileState Ok represents a Ok state for File operation.
                    
                2.5.3.1.2 compiletime FileState Fail
                    FileState Fail represents a Fail state for File operation.
        
        2.5.4 CFile
            CFile is a compiletime type reserved for manipulation operations on files stored on harddrive.
            CFile has a internal limit of 8,388,608 bytes(exactly 8 MiB) which no file created via CFile can pass.
            
            All attempts to use CFile outside of compiletime environment are ignored.
            
            2.5.4.1 Variables
                2.5.4.1.1 compiletime readonly FileState state
                    state represents the state returned by last call to any method.
            
            2.5.4.2 Methods
                2.5.4.2.1 constructor
                    2.5.4.2.1.1 constructor
                        Constructs the CFile instance with no internal file opened.

                    2.5.4.2.1.2 constructor takes string path
                        Constructs the CFile instance and opens a file handle to file under "path".
                        If such file already exists and it has not been generated by JassHelper, no file handle is opened and all
						subsequent calls to methods act as if default constructor was called.
                        
                        Path is always considered relative to the position of JassHelper.
                        
                        If file could not be opened, state will be set to Fail, otherwise state will be set to Ok.
                        
                        Note: path for file to create is always suffixed by .txt for security reasons.
                    
                2.5.4.2.2 destructor
                    Closes opened file handler, if any, and destructs CFile instance.

                2.5.4.2.3 method write takes string toWrite returns FileState
                    Attempts to write to currently opened file handle "toWrite" at current RWPosition.
                    If write was successful, advances RWPosition, sets state to Ok and returns it.
                    Otherwise sets state to Fail and returns it.
                    
                    If file handle is not open, write returns Fail.
                    
                    If file tries to write data to file which would result in being bigger than maximum size, status is set to Fail
                    and method returns it.
                
                2.5.4.2.4 method read takes integer charsToRead, boolean stopOnWhitespace = true returns string
                    Attempts to read "charsToRead" number of bytes from currently open file handle.
                    Maximum acceptable "charsToRead" is 950.
                    
                    If stopOnWhitespace is true, read will stop on next white space character, otherwise it reads until "charsToRead" characters
                    were read or until end of file.
                    
                    If file handle is not open, read returns empty string. Otherwise advanced read RWPosition and returns read string.
                    To check FileState, use state variable.
                
                2.5.4.2.5 method open takes string path returns FileState
                    Attempts to open new file handle at specified path.
                    Open follows same rules as 2.5.3.2.1.2 - constructor takes string path.
                    
                    If new file handle was opened successfully, the old one is closed as if .close was called,
                    otherwise old file handle is kept intact.
                    
                    Open sets state to whether new file handle was opened successfully and returns it.

                2.5.4.2.6 method close takes nothing returns FileState
                    Attempts to close file handle.
                    If no file handle is stored, sets state to Fail and returns it.
                
                2.5.4.2.7 method reopen takes nothing returns FileState
                    Attempts to reopen file handle.
                    
                    If no file is stored in file handle, reopen sets state to Fail and returns it.
                    Otherwise, reopen sets state to Ok and returns it.

                2.5.4.2.8 method recreate takes nothing returns FileState
                    Attempts to recreate file stored in file handle in such way that it discards the content of file and reopens it.
                    
                    If operation ended successfully, state is set to Ok and is returned.
                    Otherwise state is set to Fail and returned.

                2.5.4.2.9 method rename takes string newName, boolean preserveOld = false returns FileState
                    Attempts to rename the file stored in file handle to newName.
                    
                    If newName already exists, the operation has no effect and state is set to Fail and returned. Otherwise status is set to
                    Ok and is returned.
                    
                    If preserveOld is specified, the old file is kept. Otherwise, the old file is deleted.
                    
                2.5.4.2.10 method delete takes nothing returns FileState
                    Attempts to delete file stored in file handle.
                    Only files created with constructor or .create method can be deleted.
                    
                    Deleting file means the whole file is deleted from HDD/SSD storage unit.
                    
                    On success, state is set to Ok and is returned. Otherwise state is set to Fail and is returned.

                2.5.4.2.11 constant method getSize takes nothing returns integer
                    Returns numbers of bytes representing the file stored in file handle.
                    If no file is stored inside file handle, this function returns -1.

                2.5.4.2.12 constant method getRWPosition takes nothing returns integer
                    Returns number of bytes from the start of file stored inside file handle representing the current read and write position.

                2.5.4.2.13 constant method setRWPosition takes integer newRWPosition returns FileState
                    Attempts to set a read and write position of file stored inside file handle offset from the start of file.
                    
                    If passed value is less than 0, the RWPosition is set to beginning of file.
                    If passed value is greater than size of the file in bytes, the RWPoisition is set to the end of file.
                    
                    On success, state is set to Ok and is returned. Otherwise state is set to Fail and is returned.

                2.5.4.2.14 constant method getErrorMessage takes nothing returns string
                    Returns the last error message produced when state changes to Fail.
                    If state changes to Ok with any operation, the error message is overriden with empty string.
                
                2.5.4.2.15 method forceStoreInMemory takes boolean doForce returns boolean
                    If doForce is true, Compiler will attempt to store the whole content of file stored in file handle in memory instead
                    of reading from disk continuously. RWPosition is not updated.
                    Otherwise, the next time file is loaded into file handle, the effect will be reverted.
                    
                    forceStoreInMemory returns whether it was possible to store provided file in memory or not.
                
                2.5.4.2.16 constant method getRemainingSize takes nothing returns integer
                    Returns how many bytes until the cap of 8 MiB is left in file.
            
            2.5.5 Example of usage
                The following snippet is example of possible usage of CFile.
                
                compiletime function CreateFileSaveData takes nothing returns nothing
                    compiletime local CFile f = CFile("mapOnCompile")
                    call f.write("Compilation start\n")
                    
                    call SomeCompiletimeFunction()
                    
                    if (SomeCompiletimeBoolean) then
                        call f.write("Compilation successful!")
                    else
                        call f.write("Fail in some function")
                    endif
                    
                    call ~f()
                endfunction
            
    2.6 Conversions and Comparisons
        2.6.1 Conversions in operators
            1. Integer and real can be compared with any comparison operators
            2. Any combination of mathematical operations on Integer and real result in real
        
        2.6.2 Implicit conversion
            1. Every derived object is implicitly convertible to any of its parent types.
            2. Real is always implicitly convertible to integer, if the decimal point and decimal part is not explicitly typed.
			3. Integer is always implicitly convertible into real.
            4. null is implicitly convertible to any non-user defined type deriving from handle, including handle and string.
                Note: null is not implicitly convertible to any other type if it is explicitly cast to specific type.
            5. Conversion of type from non-constant to constant is always considered as implicit conversion.

        2.6.3 Explicit conversion
            1. Using casting operator(see 8.9 - Conversion operator), any user-defined type may be cast to any other user-defined type or to
            basic or non basic type.
            2. Basic and Non Basic types can be cast into user-defined types, but can only be cast to other
            Basic or Non Basic types if they can be implicitly converted to that type.
		
		2.6.4 Comparisons
			1. A comparison of types in compile-time environment exists with syntax: TypeA == TypeB, TypeA != TypeB.
			   This comparison is the same as Compiler.isSame(TypeA, TypeB) and !Compiler.isSame(TypeA, TypeB)
			   respectivelly.

3. Variable
    Variable stores instances of objects of particular type, which are addressable by the variable.
    Variables can be either global, visible to the whole map script, or local to function or method, visible
    only inside the function or method respectively.
    
    Variables can also be declared for structs(see 8. - Struct), or inside modules(see 11. - Module).
    
    Every variable's name must start with [a-z] or [A-Z] and must end with [a-z][A-Z][0-9].
    Variable's name can additionally contain '_' anywhere but first or last character.
    
    3.1 Global Variable
        Every global variable in vJass must be defined inside globals/endglobals block.
        
        3.1.1 Syntax
            globals
                opt:Visibility-Qualifier opt:Comp-Qualifier opt:Const-Qualifier type_name variable_name opt:=Initial_value
                ...
            endglobals
            
            Example:
                globals
                    private integer i
                    private constant integer q
                    public real r = 4.22
                    real w = 7.99
                    private compiletime real qR = 7.66
					private compiletime constant real constqR = qR
                endglobals
                
            Visibility-Qualifier is only usable, if globals block is declared within non-global Scope(see 1.3 - Scope).
            
            3.1.1.1 White spaces
                globals
                    opt:Visibility-Qualifier opt:Comp-Qualifier opt:Const-Qualifier type_name variable_name opt:(=Initial_value)
                    ...
                endglobals
                
                1. globals and endglobals keywords must be placed on separate lines
				2. Visibility-Qualifier, Comp-Qualifier and Const-Qualifier are always bound tightly into each other if provided.
                3. type_name and variable_name are bound loosely.
                4. If Initial_value is provided, it is bound loosely into preceding = and = is bound tightly with variable_name
                   Additionally, Initial_value must also follow its respective rules.
                5. Every other Syntactic Unit is bound tightly.
        
    3.2 Local Variable
        Every local variable in vJass must be defined within method or function.
		
		Local variables can be placed anywhere in function(method), and they are only usable from end of their definition.
		Additionally, local variables are only visible to the Scope they are declared in(local variable declared inside if block is
		only visible inside if block) and after the end of given Scope, the variable is no longer existing.
		
		Variables inside Scopes can, as per rule of shadowing shadow other local variables, such that variable defined inside if block
		can have the same name as variable defined before the if block, and this will not result in clash, and only the inner variable
		is modified inside given if block.
		
		Following code:
			local integer i = 0
			
			if true then
				local integer i = 5
				set i++
			endif
			
			call BJDebugMsg(i)		//prints 0
			
		as well as
			if true then
				local integer i = 5
			endif
			
			local integer i = 6
		
		is valid code.
        
        3.2.1 Syntax
            opt:Comp-Qualifier opt:Const-Qualifier local type_name variable_name opt:(=Initial_value)
            
            Example:
                local integer i
                local unit u = CreateUnit(...)
                constant local real r = 4.44
            
            Arguments of callable vJass constructs(see 4. - Function, see 8.3 - Method) also count as local variables.
            Constant locals have to be initialized before end of their definition.
            
            3.2.1.1 White spaces
                opt:Comp-Qualifier opt:Const-Qualifier local type_name variable_name opt:(=Initial_value)
                
				1. Comp-Qualifier, Const-Qualifier and keyword local are always bound tightly together if provided.
                2. type_name and variable_name are bound loosely.
                3. If Initial_value is provided, it is bound loosely into preceding '=' and '=' is bound tightly with variable_name
                   Additionally, Initial_value must also follow its respective rules.
                4. Every other Syntactic Unit is bound tightly.
            
    3.3 Temporary Variable
        Every temporary variable in vJass must be defined within method or function.
        It functions the same way as local variable, but before every assignment, other than in definition, object
        stored in the variable is destroyed/removed. The object is also destroyed before the function returns or loses control
        in any standard way.
        
        Only location, group, force, lightning, effect, trigger, region, rect or boolexpr can be declared as temporary.
        
        3.3.1 Syntax
            opt:Comp-Qualifier temporary valid_type_name variable_name opt:(=Initial_value)
            
            Example:
                temporary group g = CreateGroup()
                call GroupAddUnit(g, CreateUnit(...))
                set g = CreateGroup()                    //first calls DestroyGroup(g), and then executes this command
                
            Initial_value can be any local or temporary variable defined in the same scope before the temporary, global variable visible to
            the Defining Scope, or a literal implicitly convertible into valid_type_name.
            
            3.3.1.1 White spaces
                opt:Comp-Qualifier temporary valid_type_name variable_name opt:(=Initial_value)
                
                1. valid_type_name and variable_name are bound loosely.
                2. If Initial_value is provided, it is bound loosely into preceding '=' and '=' is bound tightly with variable_name
                   Additionally, Initial_value must also follow its respective rules.
                3. Every other Syntactic Unit is bound tightly.
    
    3.4 Array Variable
        Array Variable is such variable that has one name and can store up to 8192 different objects accessed by
        non-negative integers.
        
        The index range goes from 0 to 8191. If user tries to access element out of the bounds, nothing happens.
        
        Both global and local variables can be declared as arrays.
        
        3.4.1 Syntax
            opt:(local) type_name array variable_name opt:= {initial values}
            
            Example:
                globals
                    unit array myUnitArray = { null, null, null, CreateUnit(...), null }
					constant unit array Arr = { null, CreateUnit(...) }

            Local keyword is only provided if declaring local array variable.
            
            Temporary variables can not be marked as arrays.
            Arrays can be initialized with {} block in following way:
                comma separated values implicitly convertible into type of variable, which will be stored
                in order of their appearance starting at index 0
                    
				0 elements may also be specified between { and }.
				
				Example:
					local unit array u = {}
					//the same as local unit array u
                        
            All indices of array, with or without braces-enclosed initializer list are filled with default value of given type
            and specified indexes are filled with values inside braces-enclosed initializer list afterwards.
            
            3.4.1.1 White spaces
                opt:(local) type_name array variable_name opt:(= {initial values})
                
                1. local keyword, if provided, is bound tightly into type_name.
                2. type_name is bound tightly into 'array' keyword.
                3. array keyword is bound loosely with variable_name.
                4. Every other Syntactic Unit is bound tightly to each other.
                
                (= {Initial values}) follow these rules:
                
                    1. = Syntactic Unit and the initial value block is bound loosely to the previous syntactic unit.
                    2. = Syntactic unit is bound loosely to initial value block.
                    3. Initial value's curly brackets are bound loosely into values placed in between them.
                    4. If no initial values are used, but curly brackets are used, they are bound tightly to each other.
                    5. Every value inside 'Initial Value' block is bound loosely to every other value, but is bound tightly to
                       following comma(if any)
                    6. Closing curly bracket is bound loosely with last value.
                    7. Every other Syntactic Unit is bound tightly into any other Syntactic Unit.
            
    3.5 Struct variable
        Structs(see 8. - Struct) can contain variables, which are global to the struct, accessible from any point of the struct.
        Struct variables are also possibly accessible from outside of struct.
        
        3.5.1 Array struct variable
            3.5.1.1 Syntax
                opt:Visibility-Qualifier opt:Readonly-Qualifier
                opt:Staticity-Qualifier opt:Comp-Qualifier opt:Const-Qualifier
				type_name array variable_name [compiletime integer] opt:(= {Initial values})
                
                Example:
                    readonly unit array myArr[10]
                    private static real array myRealArray = {1., 2., 3., 4.}
					private static constant real array arr = {2., 3/4., Sin(5)}
                
                Notes:
                    Readonly-Qualifier can only be used, if Visibility-Qualifier is not specified, or is specified as public.
                    Initial values follow the same rules as 3.4 - Array variables.
                    [compiletime integer] means that there must be pair of brackets([]) with compiletime integer value inside
                    to specify number of elements reserved per instance, if the array is non-static.
                    If array is static, no size must be provided, and if one is provided, it has no effect and given array can be modified
                    past the specified size.
					Additionally, if array is initialized, it is not required to provide size, and if it does not provide size, the
					size of initialization is used instead.
                    
                    Arrays can be initialized with {} block in following way:
                    comma separated values implicitly convertible into type of variable, which will be stored
                    in order of their appearance starting at index 0
                    
                    0 elements may also be specified between { and }.
                    
                    Example:
                         unit array u = {}
                
				If struct is marked as using array, then the maximum number of instances given struct can have allocated at the same time
				is equal to floor(8190/biggest_nonstatic_array_size).
                So for instance, if there are 3 non-static arrays inside struct, with sizes 10, 10 and 15, the maximum number of
                allocated instances is 546(floor(8190/15)).
                
                3.5.1.1.1 White spaces
                    opt:Visibility-Qualifier opt:Readonly-Qualifier
                    opt:Staticity-Qualifier opt:Comp-Qualifier opt:Const-Qualifier
					type_name array variable_name [compiletime integer]
                    opt:(= {Initial values})
                    
                    1. Name of type and array keyword are bound tightly.
                    2. Name of variable and keyword array are bound loosely.
                    3. Any and all Qualifiers and name of type are bound tightly.
                    4. = Syntactic Unit and the initial value block is bound loosely to the previous syntactic unit.
                    5. = Syntactic unit is bound loosely to initial value block.
                    6. Initial value's curly brackets are bound loosely into values placed in between them.
                    7. If no initial values are used, but curly brackets are used, they are bound tightly to each other.
                    8. Every value inside 'Initial Value' block is bound loosely to every other value, but is bound tightly to
                       following comma(if any)
                    9. Every Other Syntactic Unit in Array struct variable definition is bound tightly to each other.
            
        3.5.2 Nonarray struct variable
            3.5.2.1 Syntax
                opt:Visibility-Qualifier opt:Readonly-Qualifier
                opt:Staticity-Qualifier opt:Comp-Qualifier opt:Const-Qualifier
                type_name variable_name opt:(= Initial value)
                
                Example:
                    public static constant integer myVar = 6
                    private static real myReal
                    private unit u
					compiletime constant integer i = 5
                
                Readonly-Qualifier can only be used, if Visibility-Qualifier is not specified, or is specified as public.
                Readonly-Qualifier can not be specified, if Const-Qualifier is specified.
                Static Constants must be initialized before end of their definition.
                
                3.5.2.1.1 White spaces
                    opt:Visibility-Qualifier opt:Readonly-Qualifier
                    opt:Staticity-Qualifier opt:Comp-Qualifier opt:Const-Qualifier
                    type_name variable_name opt:(= Initial value)
                    
                    1. Name of type and name of variable are bound loosely.
                    2. Every Other Syntactic Unit in Nonarray struct definition is bound tightly to each other.

4. Function
    Function is a callable, addressable vJass construct, which can have arguments passed into it and it can also return
    value.
    
    4.1 Function's Signature
        Function's signature consists of function's name and its number and type of arguments. Return type of function is not part
        of function's signature.
    
    4.2 Syntax
        4.2.1 Definition
            opt:deprecated opt:inline opt:Visibility-Qualifier
            opt:Comp-Qualifier opt:Const-Qualifier
            function function_name takes opt:arguments returns opt:Const-Qualifier return_type_name
                ...
            endfunction
            
            Arguments are of following form:
                opt:Comp-Qualifier opt:Const-Qualifier type_name1 variable_name1
                opt:(, opt:Comp-Qualifier opt:Const-Qualifier type_name2 variable_name2 ...)
                
                Every argument may declare required type as constant and/or compiletime, and arguments must be comma separated.

            Example:
                deprecated function myF takes nothing returns nothing
                    ...
                endfunction
                
                inline function myF takes integer a, integer b returns compiletime string
                    return "5"
                endfunction
                
                deprecated inline function myF takes integer a returns constant integer
                    return a
                endfunction
                
                constant function q takes nothing returns compiletime string
                    compiletime local string s = "gg"
                    return s
                endfunction
                
                constant function qW takes nothing returns compiletime string
                    return "qq"
                endfunction
                
                function qWW takes nothing returns compiletime string
                    return qW()
                endfunction
				
				function www takes compiletime constant integer i returns nothing
				endfunction
            
            If function is marked as deprecated, it will pop compiler error in Debug mode, and
            print warning in Release mode.
            
            Visibility-Qualifier is only usable when used inside non-global Scope(See 1.3 - Scope).
            If no Visibility-Qualifier is used, function is treated as public.
                 
            If function takes no arguments, then nothing shall be wrote between takes and returns.
            If function takes arguments, then they must be fully defined and they must be separated by commas.
            
            If function does not return anything, nothing must be used as return type.
            If function does return some type, then all returned values of given function must be
            implicitly convertible into specified return type, but they don't need to be of same type.
            
            Return type may me marked with constant, in which case the caller may only store it inside constant
            variable, or pass into other function as constant argument, or the variable must be of copyable type.
            
            4.2.1.1 Function argument's implicit values
                Function arguments may have implicit values specified, meaning that when the function is called, some arguments
                may end up unspecified from callers point of view, and have implicit value defined inside the function definition.
                
                opt:Comp-Qualifier opt:Const-Qualifier type_name1 variable_name1 opt:(= Initial Value) opt:(, ...)
                
                Example:
                    ... takes compiletime constant string s, constant integer i, unit u = null returns ...
                
                Notes:
                    Implicit value of variable N may only be specified, if all function's arguments to the right from N already have
                    implicit value specified, meaning that takes integer i = 5, unit u returns is malformed.
                    Implicit value can also be return value of function, in which case, return value of function must be
                    implicitly convertible to the type of variable setting implicit value for, or must be cast explicitly to
                    given type.

            4.2.1.2 White spaces
                opt:deprecated opt:inline opt:Visibility-Qualifier
                opt:Comp-Qualifier opt:Const-Qualifier
                function function_name takes opt:arguments returns opt:Const-Qualifier return_type_name
                    ...
                endfunction
                
                1. If both deprecated and inline keywords are specified, they are bound tightly.
                2. If Visibility-Qualifier is specified, and inline keyword is specified, they are bound tightly.
				3. If Comp-Qualifier is specified, it is bound loosely to preceding Syntactic Unit.
                4. If Const-Qualifier keyword is specified, it is bound tightly to both preceding Syntactic Unit and
                   'function' keyword.
                5. 'function' keyword is bound tightly to the name of function, which is bound tightly to the 'takes' keyword.
                6. all arguments are bound loosely to each other with special rules(see 4.2.1.3 - Argument's White spaces).
                7. returns keyword is bound tightly to the last argument specified in argument's list or to nothing keyword otherwise.
                8. Return type with its Qualifiers is bound tightly to 'returns' keyword.
                9. If Const-Qualifier or compiletime keywords are specified for return type, they are bound tightly with the return type.
                10. Every other Syntactic Unit is bound tightly to each other.
                
            4.2.1.3 Argument's White spaces                    
                opt:Const-Qualifier type_name1 variable_name1
                opt:(, opt: opt:Const-Qualifier type_name2 variable_name2 ...)
                
                1. If Const-Qualifier or compiletime keyword are specified, they are bound tightly to name of argument's type.
                2. Argument's name is bound tightly to name of argument's type.
                3. Comma following argument N, if specified is bound tightly into argument's name.
                4. Every independent argument is bound loosely to each other.
            
        4.2.2 Calling
            call function_name(opt:arguments)
            
            Arguments are of following form:
                opt:value1 opt:(, value2 opt:(value3 ...))
            
            Example:
                call myF(1)
                call myW(1, 2, null)
                call myQ()
                call myZ(
                         1,
                         2,
                         3,
                         null
                        )
                         
            Note:
                Every argument can be enclosed in any number of parenthesis. However, every comma must be inside
                the top bracket-scope.
                
                Example:
                    call myF(((1)), (2))    //valid
                    call myF(((1), 2))        //invalid, comma before second argument is not in top bracket-scope
        
            4.2.2.1 White spaces
                call function_name(opt:arguments)
                
                1. Keyword call and function's name are bound tightly.
                2. Opening parenthesis is bound tightly with function's name.
                3. If no arguments are provided, closing parenthesis is bound tightly with opening parenthesis.
                4. If any number of arguments are provided, then the first argument is bound loosely to the opening parenthesis,
                   the last argument is loosely bound to the last parenthesis and arguments are bound loosely between each other.
                5. Every other Syntactic Unit is bound tightly to each other.
                
            4.2.2.2 Argument's White spaces
                opt:value1 opt:(, value2 opt:(value3 ...))
                
                1. If multiple arguments are provided, then the value is bound tightly to following comma, and following comma
                   is bound loosely to the next value.
                
        4.2.4 Inlining Rules
            Function marked with inline keyword is requested to be inlined.
            Functions may be inlined only if none of the following rules are violated:
            
                - Optimization for size is specified and the length of expanded code is smaller than the size of original function
                - function is not referenced inside trigger callback, timer timeout or used as boolexpr, or types derived from boolexpr
                - Optimization for speed is specified and size function is less than 100 bytes(after other optimizations)
        
    4.3 Function overloading
        Also known as Ad-hoc Polymorphism.
        
        Functions may have the same name, and only be differentiated by their signature(see 4.1 - Function's Signature).
        If two functions only differentiate in signature by types that are implicitly convertible, these functions are conflicting.
        
        Example:
            constant function myF takes integer i returns boolean
                return i > 5
            endfunction
            
            function myF takes unit u returns integer
                return GetUnitLifePercent(u)
            endfunction
            
            call myF(GetUnitLifePercent(null))    //calls myF(integer)
            call myF(null)                        //calls myF(unit)
            
            function myF2 takes unit u returns nothing
            function myF2 takes location l returns nothing
            
            call myF2(Location(0., 0.))        //fine, calls myF2(Location)
            call myF2(null)                    //compiler error: ambiguous myF2(null), can be myF2(unit) or myF2(location)
            
            call myF2((unit)null)            //fine, calls myF2(unit)
    
    4.4 Anonymous Functions
        Also called lambda functions, are functions that are nameless.
        
        Lambda function can be passed into function expecting Extended Code Literals, or can be invoked after its definition.
        
        4.4.1 Syntax
            opt:Comp-Qualifier opt:Const-Qualifier function(opt:arguments) opt:return_type opt:catch{
                //body
            }
            
            Example:
                constant function(integer i) boolean catch{
                    return i > externalVariable
                }
            
            Notes:
                Constness as well as arguments must follow normal function rules.
                If function does not return anything, no return type is required.
                
                catch keyword allows anonymous function to use variables local to Defining Scope.
                If anonymous function is not constant and catches Defining Scope's variables, it may modify them.
                
            Manual invoking Example:
                function(integer i) boolean{
                    return i > 5
                }(5)
        
            4.4.1.1 White spaces
                opt:Comp-Qualifier opt:Const-Qualifier function(opt:arguments) opt:return_type opt:catch{
                //...
                }
                
                1. Comp-Qualifier and Const-Qualifier are bound tightly into each other as well as with function keyword, when provided.
                2. function keyword is bound tightly to the opening parenthesis.
                3. In case of no arguments, closing parenthesis is bound tightly to opening parenthesis.
                4. For every argument of type T and name N, T and N are bound tightly, together with following comma,
                   if another argument exists.
                5. Return type, if specified, is bound loosely to the closing parenthesis of arguments.
                6. catch keyword, if specified is bound tightly with return type, if specified.
                7. Opening curly brackets is bound loosely with its preceding Syntactic Unit, be it catch, return type or closing parenthesis.
                8. Closing curly bracket must be placed on separate line in regards to the body of anonymous function.
                9. If explicit call is specified after closing curly bracket, the same rules apply as to normal function's call(see 4.2.2 - Calling)
                10. Every other Syntactic Unit is bound tightly to each other.
    
    4.5 Initialization functions
        Initialization functions are such functions that perform some initial initialization of code relevant to the code in its Trigger file.
        Initialization functions must have specific name, otherwise they act as normal functions.
        
        Name format:
            InitTrig_XXXX.
        
        XXXX is the name of Trigger file, for which the initialization trigger will run.
            
5. Control flow
    Control flow allows user to control how the code runs in various ways.
    The basic control flow structures are loops and conditional blocks.
    
    5.1 Conditional block
        Conditional block allows user run code only if certain condition is met.
        
        5.1.1 Syntax
            if condition opt:(bool_operand condition2 opt:(...)) then
                ...
            elseif ...
                ...
            else
                ...
            endif
            
            Example:
                
                if myBooleanVar and not GetBoolean(null, 5.42 * 1.22) then
                    call MyFunction1()
                elseif not myBooleanVar then
                    call MyOtherFunction()
                else
                    call SomeYetAnotherFunction()
                endif
                
                if A or (not B and C) and D then
                    ...
                endif
            
            Value is such Syntactic Unit, that is implicitly evaluable into boolean. Value can be variable, return value of function or
            validly enclosed bracket-scope. not keyword is part of value.
            
            Examples:
                if not A or B then
                    - not A    = value 1
                    - B        = value 2
            
            If-Block is block of code from if keyword up until then keyword.
            Then-Block is block of code after then keyword up until matching else, endif or elseif keyword.
            ElIf-Block is block of code after then keyword preceded by elseif keyword up until matching else, endif or elseif keyword.
            Else-Block is block of code after else keyword up until matching endif keyword.
            
            Keyword if must always be followed by valid value, that is implicitly convertible into boolean.
            Additionally, the value may be preceded by not boolean operator, which will negate the resulting boolean value.
            If there is value A, then the next boolean operator after that must be in the same bracket-scope(see 1.3.1 - Bracket-scope),
            or in lower bracket-scope then A itself, or A must not be in 0th bracket-scope.
            not boolean operator is always tight up into the following value.
            And and or boolean operators must be separated by exactly one value.
            If one of the operands of and boolean operator is evaluated to false, then the whole and operator is evaluated to false.
            If one of the operands of or boolean operator is evaluated to true, then the whole or operator is evaluated to true.
            Evaluation of conditions always goes from right to left.
            
            If the result of initial if-block is true, the body of then-block is executed. Otherwise, the next if-block begins evaluation, if there is any,
            or the else-block starts execution, if it exists.
            
            Any number of if blocks can be nested into any block.
            
            5.1.1.1 White spaces
                if condition opt:(bool_operand condition2 opt:(...)) then
                    ...
                elseif ...
                    ...
                else
                    ...
                endif
                
                1. if keyword is bound tightly to the following condition.
                2. then keyword is bound tightly to the preceding condition.
                3. elseif, else and endif keywords must be placed on separate lines.
                4. Everything else is bound loosely.
            
    5.2 Compile time conditional block
        Compile time conditional block controls code generation during compilation.
        
        Special values are usable, and reserved, when using Compile time conditional block:
            - DEBUG_MODE
            - RELEASE_MODE = not DEBUG_MODE
        
        DEBUG_MODE evaluated to true, when script is being compiled in debug mode, and to false otherwise.
        
        5.2.1 Syntax
			#if condition opt:bool_operand opt:(opt:not_operand value...) then
				//SThen-Block
			#elseif ... then
				//ElIf-Block
			#else
				//Else-Block
			#endif
            
            1. #if keyword and the first condition are bound tightly.
            2. then keyword and the last condition are bound tightly.
            3. Values are bound loosely into each other.
            4. Every and and or boolean operator is bound tightly to the following value.
            5. not keyword that is part of value is bound tightly into that value.
            6. #if, #elseif, #else and #endif keywords must be placed on separate lines.
            7. Every other Syntactic Unit is bound tightly to each other.
            
			Rules:
				1. Every other vJass construct can be found within Compile time conditional block, including other Compile time
				   conditional blocks.
				2. Compile time conditional block can be found within any other vJass construct, excluding external block.
				3. Any variable declared within Compile time conditional block is not existing before the condition of given
				   conditional block is evaluated.
				   Meaning that:
						globals
							#if SomeExternalGlobalDeclaredBelow then
								//evaluates to false
								integer a = 4
							#endif
							
							#if Compiler.exists(a) then
								//since the above static if evaluated to false, the integer never got created
								//so this evaluates to false just as much
								integer b
							#endif
						endglobals
						
				   will never create integer b inside this globals block.
							
				4. The whole condition must be compiletime.
				5. If any sub-expression of the whole condition is not evaluable in compile time, the whole condition is evaluated to
				   false. Example is trying to read non compiletime variables, which will instantly yield false for the whole condition.
    
	5.3 Control flow modifiers
		5.3.1 exitwhen
			Exitwhen is special keyword followed by expression, that is evaluable into boolean result.
			If the boolean result evaluates into true, the control flow structure is immediately stopped and the code execution continues
			after the end of given control flow structure.
			
			Exitwhen can only appear inside loop(See 5.4 - Loop)
			
			5.3.1.1 White spaces
				exitwhen boolean_expression
				
				1. Exitwhen and boolean_expression are bound tightly.
				2. Boolean_expression must follow its respective rules for white spacing.
				3. The whole expression must be placed on separate line from any other code.
		
		5.3.2 break
			When break is hit inside control flow structure, the control flow structure immediately ends its execution and lets the code
			after it run.
			
			Equal to exitwhen true.
			
			Break can only appear inside Loop, While and For.
			
			5.3.2.1 White spaces
				break
				
				1. The Break expression must be placed on separate line from any other code.
		
		5.3.3 continue
			When continue is hit inside control flow structure, the code immediately jumps back into the beginning of given control flow
			structure.
			
			Continue can only appear inside Loop, While and For.
			
			5.3.3.1 White spaces
				continue
				
				1. The Continue expression must be placed on separate line from any other code.
		
    5.4 Loop
        Loop is control flow structure, that allows certain code to run multiple times, according to some condition.
        
        5.4.1 Syntax
            loop
                opt:(expressions)
            endloop
            
            Example:
                loop
                    call A(myInteger)
                    set i = i + 1
					
					if (myInteger == 5) then
						call B()
						set myInteger++
						continue
					endif
					
                    exitwhen myInteger > 10
                    set myInteger += 1
                endloop
            
            Loop-Body is block of code within loop and endloop keywords.
            Exit-Cond is condition after exitwhen keyword.
            Break-Expr is expression of type break.
			Continue-Expr is expression of type continue.

            Loop-Body can be filled with any number of valid expressions, including 0, as well as with 3 special expressions: exitwhen,
			break keywords and continue.
            
            The Loop-Body will be executed until any of the encountered Exit-Cond evaluate to true, or until Break-Expr is hit, or until
            the OP limit is reached.
            
            Exit-Cond, Break-Expr and Continue-Expr are bound into the closest higher loop block.
            One loop block can have any number of Exit-Cond, Break-Expr and Continue-Expr, and they can be nested into other vJass constructs, such as if block.
            
            5.4.1.1 White spaces
                loop
                    opt:(expressions)
                endloop
            
                1. loop keyword, as well as endloop keyword must be placed on separate lines from any other code.
                2. Every expression must follow rules of corresponding white spacing rules, so for expression of type function call, the
                   rules listed in 4.2.2.1 - White spaces.
                3. Exit-Cond as well as Break-Expr expressions must be placed on separate lines.
                4. Condition after exitwhen keyword must follow the same rules as conditions inside If-Block(5.1.1 - Syntax) and additionally
                   the first expression of the condition is bound tightly into exitwhen keyword.
                   Special case is, when the first expression is parenthesis pair, which must begin on the same line as the preceding exitwhen.
    
    5.5 While loop
        While loop is similar control flow structure as Loop, but has only one condition, which gets evaluated after each iteration of the body.
        
        5.5.1 Syntax
            while (condition)
                opt:(expressions)
            endwhile
            
            Example:
                while myInteger <= 10
                    call A(myInteger)
                    set i = i + 1
                    set myInteger += 1
                endwhile
            
            While-Body is block of code between while and endwhile keywords.
            While-Cond is condition following while keyword.
            
            While-Body gets executed as long as While-Cond evaluates to true.
            
            While-Cond must evaluate, or be implicitly convertible into boolean.
            Result of While-Cond is checked on all iterations, including the first, before entering While-Body and gets checked after
            every iteration before entering While-Body on next iteration.
            
            5.5.1.1 White spaces
                while (condition)
                    opt:(expressions)
                endwhile
                
                1. while as well as endwhile keywords must be placed on separate lines from any other code.
                2. All expressions inside While-Body must follow corresponding white spacing rules, so for expression of type function call, the
                   rules listed in 4.2.2.1 - White spaces.
                3. Condition after while keyword must follow the same rules as conditions inside If-Block(5.1.1 - Syntax) and additionally
                   the first expression of the condition is bound tightly into opening parenthesis.
                4. while keyword is bound tightly into opening parenthesis.
                5. Every other Syntactic Unit is bound tightly into each other.
            
    5.6 For loop
        For loop is a control flow structure that allows certain code to run multiple times, depending on some condition.
        
        5.6.1 Syntax
            for (opt:[initializer_list]; opt:[condition]; opt:[stepper_list])
                opt:(expressions)
            endfor
            
            Example:
                for(integer i = 0, integer j = someMaxValue; i < j; ++i)
                    call uberFunction(myEvenMoreUberArray[i])
                endfor
            
            For-Init is code block from opening parenthesis until first semicolon.
            For-Cond is code block from first semicolon until second semicolon.
            For-Step is code block from second semicolon until the closing parenthesis.
            For-Body is code between the closing parenthesis and endfor keyword.
            
            For-Init, For-Cond as well as For-Step are optional, and can be left empty for no code in that part specified.
            
            For-Init runs only once, before the first execution of For-Body.
            For-Cond runs before every iteration inside For-Body, including after For-Init.
            For-Step runs after every iteration inside For-Body.
            
            Iteration over For-Body stops only when For-Cond evaluates to true.
            
            Initializer_list serves to initialize variables used inside for body, and therefore variables defined inside Initializer_list
            cannot be referenced by name from outside the For-Body, For-Cond, For-Step or For-Init.
            Initializer_list can not have free standing function calls or set operations.
            Variables defined inside Initializer_list are shadowing any other variables with the same name.
            Variables defined inside Initializer_lsit must be separated by comma from each other.
            All Variables defined inside Initializer_list must have their type specified, omitting local or temporary keyword.
            All Variables defined inside Initializer_list are local, and can not be declared as temporary.
            
            Condition must be evaluable, or implicitly convertible into boolean value.
            
            Stepper_list servers to advance state of variables.
            Stepper_list can perform any number of calls of any function or set operations, but can not define variables.
            
            All three For blocks(For-Init, For-Cond and For-Step) are optional, and they can be provided in any combination.
            The semicolons( ; ), are however not optional, and must be provided even with any, or all empty blocks.
            
            5.6.1.1 White spaces
                for (opt:[initializer_list]; opt:[condition]; opt:[stepper_list])
                    opt:(expressions)
                endfor
                
                1. for keyword is bound tightly into opening parenthesis.
                2. opening parenthesis is bound to 'local' keyword, if any variables are provided, otherwise the semicolon following
                   initializer_list is bound tightly to opening parenthesis.
                3. All variables declared inside initializer_list must be separated by comma, and are bound loosely to each other.
                   However, comma after every variable defined, but the last one, is bound tightly to the variable defined before it.
                4. Variable definition must follow the same rules as normal variable definition(3.2 Local Variable)
                5. Condition is bound loosely to the previous semicolon.
                6. Condition is bound tightly to the following semicolon.
                7. If no condition is provided, semicolons are bound loosely to each other.
                8. First expression of Stepper_list is bound tightly to previous semicolon.
                9. If no Stepper_list is provided, the closing parenthesis is bound loosely into second semicolon.
                10. Stepper_list expressions must be separated with commas, and are bound loosely to each other.
                11. Expressions inside Stepper_list must follow their respective rules, including white spacing.
                12. Every other Syntactic Unit is bound tightly into each other.

6. Scope
    Scope is vJass construct that allows encapsulating other vJass constructs.
    Therefore, Visibility-Qualifiers can be applied where applicable on vJass constructs inside scope.
    
    Scope can contain any other vJass construct, except library and every vJass construct inside must follow
    respective rules defined for given vJass construct.
    
    6.1 Syntax
        opt:Visibility-Qualifier scope scope_name opt:(initializer init_function_name)
            Scope-Body
        endscope
        
        Example:
            scope MyScope
                function a takes nothing returns nothing
                endfunction
            endscope
            
            scope MyOtherScope initializer i
                private function i takes nothing returns nothing
					call MyScope.a()				//See 1.3.2 - Scope resolution
                endfunction
            endscope
        
        Visibility-Qualifier is only usable if given scope is inside another scope, or library.
        
        Scope can declare exactly one function or static method from inside the Scope's body as its initializer.
        This function is ran exactly once(unless explicitly called) according to 1.14 - Initialization rules.
    
        6.1.1 White spaces
            opt:(Visibility-Qualifier) scope scope_name opt:(initializer init_function_name)
                Scope-Body
            endscope
            
            1. Visibility-Qualifier, if specified, is bound tightly into scope keyword.
            2. scope keyword is bound tightly into scope_name.
            3. Scope_name is bound tightly into initializer keyword, if provided.
            4. initializer keyword is bound tightly into init_function_name, if provided.
            5. endscope keyword must be placed on separate line from other code.

7. Library
    Library is vJass construct, similar to scope, which allows encapsulation of other vJass constructs.
    
    Library can contain every other vJass construct, excluding another library and every vJass construct inside library
    must follow its respective rules.
    Therefore libraries can only be placed in Global Scope.
    
    7.1 Syntax
        library lib_name opt:(initializer init_func_name) opt:(requires/uses/needs opt:[optional] required_lib_name)
            Library-Body
        endlibrary
        
        Example:
            library MyLibrary initializer i uses A, optional B, C
                //Code Code Code
            endlibrary
        
        Library can declare exactly one function or static method from inside the Library's body as its initializer.
        This function is ran exactly once(unless explicitly called) according to 1.14 - Initialization rules.
        
        Library can also declare that it wants to use vJass constructs from another library with keyword uses, needs or requires.
        All required libraries must have names of existing library anywhere in the Global Scope, and their names can be pre-placed with
        optional keyword, meaning that if such library does not exist inside Global Scope, no compiler error will be issued.
        If more than one required library is specified, the libraries must be separated with commas.
        All required libraries, however, must not depend in any way on the library that depends on them, therefore creating circular dependencies.
        
        Every library must have such unique name, that there is no other library in the Global Scope(See 1.3 - Scope) with the same name.
        
        7.1.1 White spaces
            library lib_name opt:(initializer init_func_name) opt:(requires/uses/needs opt:[optional] required_lib_name)
                Library-Body
            endlibrary
            
            required library entry:
                opt:(optional) lib_name
            
            1. library keyword is bound tightly into lib_name.
            2. Lib_name is bound tightly into initializer keyword, if provided.
            3. initializer keyword is bound tightly into init_func_name, if provided.
            4. If needs, uses or requires keyword is provided, it is bound tightly into the previous Syntactic Unit.
            5. If needs, uses or requires is provided, it is bound tightly into the first required library entry.
            6. optional keyword is bound tightly into the following lib_name.
            7. Required_library_name is bound tightly with the following comma, if any more required libraries are provided.
            8. Required library entries are bound loosely into each other.
            9. Every other Syntactic Unit is bound tightly into each other.
    
8. Struct
    Struct is a used-defined type, which can contain other types as well as methods describing its behaviour and operators
    for easier access to members, or overloading existing operators for user-friendly syntax.
    
    Structs automatically generate several methods, see 8.6.5 - Automatically generated methods.
    
    All members as well as methods defined inside struct can be accessed using dot-syntax(AA.bb will access member of name bb inside AA, which
    can be either variable of some user-defined type, or name of user-defined struct).
    
    8.1 Syntax
        8.1.1 Definition
            opt:Comp-Qualifier opt:Visibility-Qualifier struct struct_name opt:(uses array/hashtable) opt:(final) opt:(extends parent_list)
                Struct-Body
            endstruct
            
            Example:
                struct A
                    ...
                endstruct
                
                struct B uses array
                    ...
                endstruct
                
                struct C extends A
                endstruct
                
                struct Q final extends C
                endstruct
            
			If Comp-Qualifier is used, the uses array/hashtable is only considered if given struct is used in runtime environment and has no
			effect in compiletime environment.
			
            Visibility-Qualifier is only usable, if given struct is defined inside scope(see 6. - Scope) or library(see 7. - Library).
            
            If struct is marked as final, it can no longer be inherited(see 8.10 - Inheritance and Polymorphism).
            
            Structs can extend from any number of parent structs(see 8.10 - Inheritance and Polymorphism).
            Structs automatically generate several methods when use is requested(see 8.6 - Automatically generated methods).
            
            Uses keyword marks what will the struct use to store its indices in.
            If none is provided, implicit value of array is assumed.
            
            Struct that uses array will only allow at 8190 instances concurrently allocated.
            Struct that uses hashtable allows any number of instances at the same time.
            
            If non-static array member variable is defined with size N then maximum number of simultaneously allocated instances
            is floor(Normal_Max / N).
            
            If struct uses hashtable or array, all structs that inherit from it will also use hashtable or array, regardless of type provided
            in uses.
            
            8.1.1.1 White spaces
                opt:Comp-Qualifier opt:Visibility-Qualifier struct struct_name opt:(uses array/hashtable) opt:(final) opt:(extends parent_list)
                    Struct-Body
                endstruct
                
				1. If provided, Comp-Qualifier is bound tightly into following Syntactic Unit.
                2. If provided, Visibility-Qualifier is bound tightly into both preceding and following Syntactic Unit.
                3. struct keyword is bound tightly into struct_name.
                4. Struct_name is bound tightly with uses keyword, if provided.
                5. uses keyword is bound into array/hashtable modifier tightly.
                6. final keyword is bound tightly into preceding Syntactic Unit and tightly to following(if any).
                7. If extend_list is provided, the keyword extends is bound loosely into the first entry from parent_list.
                8. Every entry in parent_list is bound loosely to the preceding Syntactic Unit, tightly into the following comma(if any)
                   and loosely to the following entry from parent_list(if any).
                9. Every other Syntactic Unit is bound tightly into each other.
        
        8.1.2 Member access
            opt:(this/thistype) opt:( . ) member_name
            name.member_name
            
            Both this variable, respectively thistype keyword and dot are optional.
            If access to members of different struct is required, either name of the struct must be provided, in case of access to static members,
            or name of object of given type must be specified, in case of access to either static or non-static members.
            
            Member_name must be valid member from inside the referenced struct.
            
            'name', as well as this/thistype can be enclosed in any number of brackets, meaning that following: ((Soemthing.some).else).e = 5
            is valid syntax.
            
            8.1.2.1 White spaces
                opt:(this/thistype) opt:( . ) member_name
                name.member_name
                
                1. If provided, this variable/thistype keyword is bound tightly into the following dot.
                2. If provided, the dot is bound tightly into member_name.
                3. If second version is used, name is bound tightly into dot, and dot is bound tightly into member_name.
                4. If parenthesis enclose 'name' or this, or thistype, the bracket-scope is bound tightly into following dot.
        
    8.2 Variable definition
        See 3.5 - Struct variable.
        
        All variables with initial values are initialized when instance is allocated.
        
        8.2.1 this variable
            While inside methods of struct, the currently running instance of the object of the struct can be referenced using
            this variable.
            
            this variable, however, is only implicitly available from inside non-static methods, and inside static methods, it must be
            declared explicitly, or it cannot be used.
			
			Please note that this behaviour will be removed in later verisons.
            
            No variable defined inside body of struct can be called this.
            
            Every member variable must have such unique name, that there is no other member variable or method defined with the same name
            inside the same struct.
            
            Example:
                struct A
                    integer q
                    
                    method myMethod takes nothing returns nothing
                        set this.q = 5
                    endmethod
                    
                    static method myStaticMethod takes nothing returns nothing
                        local thistype this = someArray[56]
                        set this.q = 5
                    endmethod
                endstruct
    
    8.3 Methods
        Method is a function inside struct, which defines specific behaviour of struct.
        Methods can either be static, or non-static.
        Static methods define specified, shared behaviour for all instances, whereas non-static methods can work
        on instances independently.
        
        Methods also obey rules specified in 4.3 - Function overloading.
        
        8.3.1 Syntax
            8.3.1.1 Definition
                opt:(deprecated) opt:(inline)
                opt:(Visibility-Qualifier) opt:(Comp-Qualifier) opt:(Const-Qualifier)
                opt:(Staticity-Qualifier) opt:(override) opt:(stub)
                method opt:(operator) takes opt:(arguments) returns opt:(Constant-Qualifier) return_type
                    Method-Body
                endmethod
                
                Arguments are of following form:
                    opt:Comp-Qualifier opt:Const-Qualifier type_name1 variable_name1
                    opt:(, opt: opt:Comp-Qualifier opt:Const-Qualifier type_name2 variable_name2 ...)
                
                Example:
                    private static method m takes nothing returns nothing
                        //code
                    endmethod
                    
                    stub method q takes nothing returns integer
                        return 5
                    endmethod
                    
                    method operator += takes integer i returns thistype
                        set this.storage = this.storage + 1
                        return this
                    endmethod
                
                For override keyword, as well as stub methods, please check Inheritance.
                
                Deprecated and inline keywords follow the same rules as in function definition(see 4.2 - Definition Syntax).
                
                Methods and method operators defined as static can not use implicit variable this, unless defined explicitly
                inside the body of the method.
				
				This feature will be removed in later version.
                
                If method takes no arguments, then nothing shall be wrote between takes and returns.
                If method takes arguments, then they must be fully defined and they must be separated by commas.
                
                If method does not return anything, nothing must be used as return type.
                If method does return some type, then all returned values of given method must be
                implicitly convertible into specified return type, but they don't need to be of same type.
                
                Methods marked as constant can be called from both constant and non-constant instance, and may not modify
                any global state, or state of the object that the method is called on. The object inside the method is marked as constant.
                Static members of struct can be modified from constant methods.
                
                Non-static member variables of struct can have their value changed from constant method if they are declared as mutable.
                
                Normal methods can not be called from constant instances of object.
                
                Methods can call other methods only if they are defined below the called methods.
                
                8.3.1.1.1 Method argument's implicit values
                    Method arguments may have implicit values specified, meaning that when the method is called, some arguments
                    may end up unspecified from callers point of view, and have implicit value defined inside the method definition.
                    
                    opt:Comp-Qualifier opt:Const-Qualifier type_name1 variable_name1 opt:(= Initial Value) opt:(, ...)
                    
                    Example:
                        ... takes compiletime integer q, constant integer i, unit u = null returns ...
                    
                    Notes:
                        Implicit value of variable N may only be specified, if all method's arguments to the right from N already have
                        implicit value specified, meaning that takes integer i = 5, unit u returns is malformed.
                        Implicit value can also be return value of method, in which case, return value of method must be
                        implicitly convertible to the type of variable setting implicit value for, or must be cast explicitly to
                        given type.

                8.3.1.1.2 White spaces
                    opt:(deprecated) opt:(inline)
                    opt:(Visibility-Qualifier) opt:(Comp-Qualifier) opt:(Const-Qualifier)
                    opt:(Staticity-Qualifier) opt:(override) opt:(stub)
                    method opt:(operator) name takes opt:(arguments) returns opt:(Constant-Qualifier) return_type
                        Method-Body
                    endmethod
                    
                    1. If both deprecated and inline keywords are specified, they are bound loosely.
                    2. If Visibility-Qualifier is specified, and inline keyword is specified, they are bound tightly.
					3. If Comp-Qualifier is specified, it is bound loosely to preceding Syntactic Unit.
					4. If Const-Qualifier is specified, it is bound tightly into preceding Syntactic Unit and loosely to following.
                    5. If Staticity-Qualifier is provided, it is bound loosely into preceding and tightly to following Syntactic Unit.
                    6. override and stub keywords are bound together, if either provided. If not, either of provided keyword is
                       bound tightly into preceding Syntactic Unit and is bound loosely into following Syntactic Unit.
                    7. operator keyword, if provided is bound tightly into method keyword.
                    8. Preceding keyword is bound tightly to the name of method, which is bound tightly to the takes keyword.
                    9. all arguments are bound loosely to each other with special rules(see 4.2.1.3 - Argument's White spaces).
                    10. returns keyword is bound loosely to the last argument specified in argument's list or to nothing keyword otherwise.
                    11. Return type with its Qualifiers is bound loosely to returns keyword.
                    12. If Const-Qualifier is specified for return type, it is bound tightly with the return type.
                    13. Every other Syntactic Unit is bound tightly to each other.
                    
                8.3.1.1.3 Argument's White spaces                    
                    opt:Comp-Qualifier opt:Const-Qualifier type_name1 variable_name1 opt:(= Initial_value)
                    opt:(, opt: opt:Const-Qualifier type_name2 variable_name2 ...)
                    
                    1. Comp-Qualifier and Const-Qualifier are bound tightly together, and if any or both provided, they are bound tightly to name of argument's type.
                    2. Argument's name is bound tightly to name of argument's type.
                    3. Initial_value, as well as = is bound tightly into variable_name, if provided.
                    4. Comma following argument N, if specified is bound tightly into argument's name.
                    5. Every independent argument is bound loosely to each other.
                
            8.3.1.2 Calling
                call opt:(this) opt:( . ) method_name(opt:arguments)
                call variable.method_name(opt:arguments)
                
                Arguments are of following form:
                    opt:value1 opt:(, value2 opt:(value3 ...))
                
                Example:
                    call myF(1)
                    call .myW(1, 2, null)
                    call this.myQ()
                    call variable.myZ(
                             1,
                             2,
                             3,
                             null
                            )
                             
                If the first calling method is used, and this keyword is provided, the following dot is necessary.
                
                Note:
                    Every argument can be enclosed in any number of parenthesis. However, every comma must be inside
                    the top bracket-scope.
                    
                    Example:
                        call myF(((1)), (2))    //valid
                        call this.myF(((1), 2))    //invalid, comma before second argument is not in top bracket-scope
            
                8.3.1.2.1 White spaces
                    call opt:(this) opt:( . ) method_name(opt:arguments)
                    call variable.method_name(opt:arguments)
                    
                    1. Keyword call and following Syntactic Unit are bound tightly into each other.
                    2. Opening parenthesis is bound loosely with method's name.
                    3. If no arguments are provided, closing parenthesis is bound tightly with opening parenthesis.
                    4. If any number of arguments are provided, then the first argument is bound loosely to the opening parenthesis,
                       the last argument is loosely bound to the last parenthesis and arguments are bound loosely between each other.
                    5. Every other Syntactic Unit is bound tightly to each other.
                    
                8.3.1.2.2 Argument's White spaces
                    opt:value1 opt:(, value2 opt:(value3 ...))
                    
                    1. If multiple arguments are provided, then the value is bound tightly to following comma, and following comma
                       is bound loosely to the next value.

    8.4 thistype keyword
        While inside struct, thistype keyword can be used, which gets transformed into the name of struct currently being parsed.
        thistype keyword will not be replaced inside strings.
        
        Example:
            struct QQ
                static method a takes nothing returns thistype
                    return thistype.allocate()
                endmethod
            endstruct
            
            will get converted into
            
            struct QQ
                static method a takes nothing returns QQ
                    return QQ.allocate()
                endmethod
            endstruct
        
        8.4.1 Thistype cast
            Thistype keyword(as well as user_type, see 8.9.3 - Predefined conversion operations) can also be used
            to convert unique identifier of type integer of that type into instance.
        
            Example:
                call functionExpectingInstance((thistype)5)    //calls functionExpectingInstance with instance
                                                               //with number 5
            
            If instance with given unique identifier is not allocated the values are still affected, and when the instance
            is allocated it can have malformed values, unless overridden after creation.
    
    8.5 Keyword redundancy
        Because both this variable and thistype keyword operate on members and methods of currently parsed struct, they can be omitted.
        The dot preceding the members inside currently being parsed struct can also be omitted.
        
        Both omissions are optional.
        
        Example:
            struct AA
                integer w = 5
                static integer q = 0
                method myA takes nothing returns nothing
                    set w = w + 1                //1
                    set .w = .w + 1                //equivalent to 1
                    set this.w = this.w + 1        //equivalent to 1
                    
                    set q = q + 1                    //2
                    set .q = .q + 1                    //equivalent to 2
                    set AA.q = AA.q + 1                //equivalent to 2
                    set thistype.q = thistype.q + 1    //equivalent to 2
                endmethod
            endstruct
    
    8.6 Automatically generated methods
        All automatically generated methods are only actually generated when code requires usage of given methods.
        
        8.6.1 private static method allocate takes nothing returns thistype
            Allocate is static method, that takes nothing and returns new, unique instance of given type.
            This method is private, so it cannot be called from outside the struct.
            This method is un-overloadable.
            This method is not generated unless used.
        
        8.6.2 private method deallocate takes nothing returns nothing
            Deallocate is static method which pairs up with allocate. Deallocate takes the running instance and puts it back into
            bucket of free instances, effectively destructing the instance.
            This method is private, so it cannot be called from outside the struct.
            This method is un-overloadable.
            This method is not generated unless used.
        
        8.6.3 private static method onInit takes nothing returns nothing
            onInit is a static method, which is executed with script's initial initialization.
            The default implementation is empty. This method can be overloaded and any attempt in doing so will result in the
            automatically generated to not be generated.
            Overloaded onInit method may return any value, must not have any parameters and must be static.
            Overloaded onInit method can be declared as private and will still be executed with initial execution.
            
        8.6.4 legacy create and destroy
            For backwards compatibility reasons, a default static method create takes nothing returns nothing and
            method destroy takes nothing returns nothing are generated when not overloaded and use of them is requested,
            which forward call allocate and deallocate respectively.
            These methods are deprecated and automatic generation of create and destroy will be removed in future version of JassHelper.
    
    8.7 Constructor and Destructor
        Constructor and destructor are special methods which are called when instance of struct is created and destroyed respectively.
		When constructor is generated, allocate is also generated, and analogically for destructor/deallocate.
        
        8.7.1 Syntax
            8.7.1.1 Declaration
                constructor opt:(takes arguments)
                    Constructor-Body
                endconstructor
                
                destructor
                    Destructor-Body
                enddestructor
                
                Example:
                    struct A
                        private unit u
                        private boolean b
                        constructor
                            set u = CreateUnit(Player(0), 'hfoo', 0, 0, 0)
                            set b = true
                        endconstructor
                        
                        constructor takes unit u
                            set this.u = u
                            set b = false
                        endconstructor
                        
                        destructor
                            if b then
                                call KillUnit(u)
                            endif
                        enddestructor
                    endstruct
                
                Constructor and destructor can be overloaded like normal functions and may take any number of any arguments.
                If they take no arguments, a takes nothing is optional.
                
                Constructor and destructor never specify return types.
                
                Constructor implicitly calls underlying .allocate(), which can be provided in allocators(See 12. - Allocator) and
                after executing it returns allocated instance into caller.
                
                Created instance can be pointed at with this variable.
                
                Destructor always calls .deallocate(), which can be provided in allocators(See 12. - Allocator) after executing the body of destructor.
                
                If no user-defined constructor is provided and is requested, a default constructor with no arguments is generated with empty body.
                If no user-defined destructor is provided and is requested, a default destructor with no arguments is generated with empty body.
                
                Additionally, if no user-defined constructor which takes exactly 1 integer is provided, a implicit one is generated
                which returns instance with id equal to argument it is called with.
                
                Example:
                    local A a = thistype(5)
                    local integer i = a.someInteger
                    local A b = thistype(i).someInteger
                
                Mixing crate call and destructor, or constructor and destroy is only safe if:
                    1. First line of create contains local thistype this = allocate() and on every possible path of execution
                       returns given value.
                    2. Destroy's last operation before return statement or falling off of scope is call deallocate().
                
                8.7.1.1.1 White spaces
                    constructor opt:(takes arguments)
                        Constructor-Body
                    endconstructor
                    
                    destructor
                        Destructor-Body
                    enddestructor
                    
                    1. constructor, destructor, endconstructor and enddestructor must be placed on separate lines.
                    2. If arguments are provided for constructor, then constructor is bound tightly into takes keyword and
                       separate arguments follow the same rules as in arguments for normal method(See 8.3.1.1 - Definition).
            
            8.7.1.2 Invocation
                Construction: call MyType(opt:[args]), call thistype(opt:[args])
                Destruction: call ~MyType(opt:[args]), call ~thistype(opt:[args])
                
                Example:
                    struct S
                        constructor
                        endconstructor
                        
                        constructor takes integer a
                        endconstructor
                        
                        destructor
                        enddestructor
                        
                        destructor takes boolean b
                        enddestructor
                    endstruct
                    
                    local S s = S()
                    local S q = S(5)
                    //do work with s
                    call ~s()
                    call ~q(true or false)
                
                The de-facto function called should always be the same as the name of the construction object.
                
                To destruct object, a ~ shall be placed before de-facto function name equal to the name of instance.
                
                8.7.1.2.1 White spaces
                    call MyType(opt:[args])
                    call ~MyType(opt:[args])
                    
                    1. Normal function call rules must apply.
                    2. There may be no white space between [lass]~ and first letter of structs name.
    
            8.7.1.3 Construction of parent structs
                Structs can explicitly declare which constructor to use when constructing parent structs.
                
                8.7.1.3.1 Syntax
                    construct ParentA(parent1args), ParentB(parent2args)...
                    
                    Example:
                        struct D extends A, C, B
                            constructor
                                construct A(5), B("string"), C()
                            endconstructor
                        endstruct
                    
                    Construct is only valid if it is placed before any other expression inside constructor of substruct.
                    
                    If Construct is not provided, a default constructor is called for each parent.
                    If list of parents after Construct does not include any parent structs, all missing parent structs are constructed using
                    default constructor.
                    
                    Struct names can be in any order and will not change the order of construction of individual
                    structs(See 8.10.3 - Order of creation and destruction of objects).
                    
                    this variable can not be used inside construct expression, because the type is not yet fully constructed.
                    
                    8.7.1.3.1.1 White spaces
                        construct ParentA(parent1args), ParentB(parent2args)...
                        
                        1. construct is bound tightly into the first parent struct's name.
                        2. Calls to parent structs must following rules of constructor call(See 8.7.1.2.1 - White spaces).
    
    8.8 Method operator
        Method operators are methods with unorthodox syntax for invocation.
            
		8.8.1 List of overloadable operators
			Operator declaration                                Example of usage
			
			1. method operator +                                set lhs = instance + rhs
			2. method operator -                                set lhs = instance - rhs
			3. method operator *                                set lhs = instance * rhs
			4. method operator /                                set lhs = instance / rhs
			5. method operator %                                set lhs = instance % rhs
				
			6. method operator ++                               set instance++

			7. method operator --                               set instance--
				
			8. method operator +=                              set instance += rhs
			9. method operator -=                              set instance -= rhs
			10. method operator *=                              set instance *= rhs
			11. method operator /=                              set instance /= rhs
			12. method operator %=                              set instance %= rhs
				
			13. method operator <<                              set lhs = instance << rhs
			14. method operator >>                              set lhs = instance >> rhs
			15. method operator <<=                             set instance <<= rhs
			16. method operator >>=                             set instance >>= rhs
				
			17. method operator ==                              instance == rhs
																lhs == instance
			18. method operator !=                              instance != rhs
																lhs != instance

			19. method operator <=                              instance <= rhs
			20. method operator >=                              instance >= rhs
			21. method operator <                               instance < rhs
			22. method operator >                               instance > rhs
			23. method operator !                               !instance
				
			24. method operator []                              call SomeFunction(instance[argument])
			25. method operator []=                             set instance[argument] = second_argument
			26. static method operator []                       call SomeFunction(StructName[argument])
			27. static method operator []=                      set StructName[argument] = second_argument
			
			Note: instance is always of user-defined type, while rhs and lhs are of undefined type(depending on signature of operator).
		
			Arguments of operators:
				1. Operators 1-5, 8-22, 24 and 26 require exactly one argument.
				2. Operators 6-9 as well as 25 require no parameters.
				3. Operators 27 and 29 require exactly two arguments.
				
			Return values of operators:
				1. Operators 1-5, 8-12, 15, 16, 25 and 27 may not return any value.
				2. Operators 6-7, 13, 14, 17-24 and 26 must return a value.
			
			Boolean operators(17-22) can be performed on implicitly convertible types without need of such method operator to exist.
			
			If operator 23 is not provided, implicit version is generated, returning whether given instance of user-defined type
			was allocated successfully.
			
			Assignment operator is not overloadable, but is always implicitly declared(See 8.9.3 - Predefined Conversion operators)
			for every type to accept the same type or implicitly convertible types.
			
			For example:
				local A a = A()
				local A b = a
				
				local integer i = 5
				local real r = i
			
			is valid code.
        
    8.9 Conversion operator
        Conversion operators allow conversion from one user-defined type to another, or to native type(either basic or non-basic).
        
        8.9.1 Declaration Syntax
            method operator ValidType
                operator-body
            endmethod
            
            Conversion operators never take any arguments, and they must always return value that is implicitly convertible
            into ValidType on all paths of execution.
            
            Only one conversion operator to given type can exist inside one struct.
            
            ValidType must be fully defined at point of method operator definition.
            
            Additionally, every instance of user-defined object can be implicitly converted to boolean, checking if given instance
            was allocated successfully.
            
            8.9.8.1 White spaces
                method operator ValidType
                    operator-body
                endmethod
                
                1. method and operator keywords are bound tightly.
                2. operator keyword is bound tightly with ValidType.
                3. There must be any number of white spaces ending with new line character after ValidType.
                4. endmethod keyword must be placed on separate line.
        
        8.9.2 Invocation Syntax
            Form 1:    (ValidType)instance
            Form 2:    Compiler.convert(instance, ValidType)
            
            Conversion operator is always explicit, and therefore the type to convert to must be fully mentioned at all times.
            
            Conversion operator may not be followed by dot.
            
            8.9.8.2 White spaces
                Form 1:    (ValidType)instance
                
                1. Every Syntactic Unit is bound tightly into each other.
                
                Form 2:    Compiler.convert(instance, ValidType)
                
                1. Normal rule of static method invocation apply(see 8.3.1.2.1 - White spaces).
        
        8.9.3 Predefined Conversion operators
            For ease of use, few conversion operators are generated implicitly:
            
                1. method operator string(integer) equal to I2S
                2. method operator string(real) equal to R2S

                3. method operator integer(string) equal to S2I
                4. method operator real(string) equal to S2R

                5. implicit method operator integer(real) equal to R2I
                6. method operator real(integer) equal to I2R

                7. method operator thistype(integer)
                8. method operator user_type(integer)

                9. implicit method operator boolean(thistype)
                
                Special Conversion Operators:
                    7.Alt. thistype(integer_value)
                    8.Alt. user_type(integer_value)
                    
                    This cast operators are deprecated and outdated, and are kept for backwards compatibility.
                    Proper operators are (thistype)integer_value and (user_type)integer_value.
                    
                    Please note that if user-defined conversion operator is provided for integer, both 7 and 8 will call
                    that operator instead of doing direct conversion from integer to instance.
        
        8.9.4 Predefined constructors
            For ease of use, few predefined constructors are generated implicitly:
                
                1. integer.constructor(thistype)
                
                2. real.constructor(integer)
                3. integer.constructor(real)
                
                4. string.constructor(integer)
                5. string.constructor(real)
                
                6. boolean.constructor(thistype)
                
            Example:
                local MyType m = MyType()
                local integer q = integer(m)                  //calls 1
                local real w = real(q)                        //calls 2
                
                local string o = string(w)                    //calls 5
                local string p = string(q)                    //calls 4
                
                local boolean isAllocated = boolean(m)        //calls 6
    
    8.10 Inheritance and Polymorphism
        Polymorphism allows exact code implementation to be hidden under certain signature.
        
        To make struct polymorphic in vJass, it must be inheritable(see 8.9.2 - Rules of Inheriting).
        Only stub methods(see 8.11 - Stub Method) can have polymorphic behaviour.
        
        Inheriting from a base struct allows the struct to derive methods and member variables from its parents.
        
        8.10.1 Syntax for Inheriting
            struct A extends Parent1, Parent2, ...

        8.10.2 Rules of Inheriting
            1. Struct that extends array or is marked as final can not be inherited
            2. Only public members and variables are derived from parent struct
            3. None of create and destroy methods are inherited
            4. Native types and non-basic types may not be derived
        
        8.10.3 Order of creation and destruction of objects
            All structs are constructed in top-down order, meaning that the top-most parent struct(struct that does not inherit anything)
            will be constructed first, followed by its child that is bridging the top-most struct with the bottom-most, and so on
            until the struct that is being created is not created.
            If there exists a diamond-shape(B and C inherit A and D inherits B and C), only one instance of A will be created
            when object D is created, and the creation depends on the order of declaration in extend list.
            
            Destruction happens in down-top order, meaning that the destructing struct is deallocated first, and after that
            its parents destruct themselves and so on, until the top-most struct is destructed.
            If there exists a diamond-shape(B and C inherit A and D inherits B and C), A-part of object D will only be destroyed once.
            
            Construction and destruction always goes in the same order as in extend list, meaning that struct C extends A, B
            when constructed will first construct A and its parents, and then B and its parents, and when destructed will first destruct A
            and its parents and then B and its parents.
    
    8.11 Stub Method
        Stub method is such method, that can be overridden(don't confuse with overloaded) in children of implementing struct.
        Stub methods follow rules of normal methods for both white spacing and declaration, as well as invoking.
        
        When calling stub method in derived struct that does not override the stub method is invoked, the nearest parent with
        stub method with given name and signature will be executed.
		
		Templated methods can not be declared as stubs.
        
        8.11.1 Rules of overriding
            1. Overridden method must have the exact same arguments as well as return type, and must have the same Const-Qualifier
               as the overriding method, otherwise the method is merely a overload.
            2. Overridden method does not need to have the same Visibility-Qualifier.
            3. Overridden method does not need to be stub.
            4. static methods can not be overridden, therefore can not be declared as stub methods.
            5. destroy and create methods can not be overridden, therefore can not be declared as stub methods.
        
    8.12 override method
        Override method is such method, that will try to override parent's stub method.
        If no overridable stub method with given signature and return type exists in any of parents, the method pops compilation error.
        
        Override method does not need, but can, be stub method.
        
        Example:
            struct A
                stub method a takes integer i returns nothing
                endmethod
            endstruct
            
            struct B extends A
                override method a takes real r returns nothing    //OOPS! wrong type, compilation error
                endmethod
            endstruct
    
    8.13 super variable
        Special, reserved variable super is used when manual invocation of parent's method that is overridden in struct declaring
        running method is requested.
        
        Example:
            struct A
                stub method m takes integer a returns nothing
                    call BJDebugMsg((string)a)
                endmethod
            endstruct
            
            struct B extends A
                method m takes integer a returns nothing
                    call BJDebugMsg("Son running parent")
                    call super.m(a)
                endmethod
            endstruct
        
        If more than one parent have stub method with the same signature then conversion cast must be used on super variable.
        
        Example:
            struct A
                stub method m takes integer a returns nothing
                    call BJDebugMsg((string)a)
                endmethod
            endstruct
            
            struct B
                stub method m takes integer a returns nothing
                    call BJDebugMsg("B: " + (string)a)
                endmethod
            endstruct
            
            struct C extends A, B
                method m takes integer a returns nothing
                    call ((A)super).m(a)        //calls A.m, outputs "a"
                    call ((B)super).m(a)        //calls B.m, outputs B: "a"
                endmethod
            endstruct
    
    8.14 Visibility-Block
        Visibility-Block allows different variables as well as methods to be grouped under single Visibility-Qualifier without need
        to specify it.
        
        8.14.1 Syntax
            private:
            public:
            ...
            endblock
            
            Example:
                struct S
                    private:
                    
                    static method onInit takes nothing returns nothing
                    endmethod
                    //onInit is private
                    
                    public method q takes nothing returns integer
                        return 5
                    endmethod
                    //q is public
                    
                    endblock
                    
            Starting and ending of Visibility-Block must be placed outside of any method's body.
            
            If method or variable declares different Visibility-Qualifier than enclosing Visibility-Body does, visibility is set
            to the Visibility-Qualifier set for each method or variable individually.
            
            Alternation in Visibility-Body can happen before ending of Visibility-Body.
            
            Example:
                private:
                
                static method operator [] takes integer i returns integer
                    return i
                endmethod
                
                public:
                
                method q takes nothing returns nothing
                endmethod
                
                endblock

            8.14.1.1 White spaces
                private:/public:
                ...
                endblock
                
                1. ':' is bound tightly into public/private keywords.
                2. endblock must be placed on separate line from other code.
            
9. Interface
    Interface is special struct, with different declaration keyword, which can contain variables and methods and can not be child of any
    other struct or interface.
    Methods in interface, unlike in struct, does not need, and can not provide any body.
    The only provided parts of methods are their signature and return type.
    
    9.1 Syntax
        9.1.1 Definition
            interface name
                Interface-Body
            endinterface
            
            Interface, unlike struct, can not extend from any other interface or struct.
            Every variable declared inside interface must follow rules of declaring variables inside struct(See 3.5 - Struct Variable).
            Every method declared inside interface must follow rules of method declaration, excluding endmethod keyword(See 8.3 - Methods).
            
            Children of interfaces are non-instancable, unless they provide implementation of all methods
            that do not default and they cannot use thistype casts as well.
            
            If direct children of interface does not provide implementation of all methods that are not default, but any of its children
            do provide body for the methods, then the children can be instantiated.
            
            Every interface must have such unique name, that there exists no other private Name-Referable Construct and other interface
            with the same name in the same Scope as well as public in Global Scope.
            
            9.1.1.1 White spaces
                interface name
                    Interface-Body
                endinterface
                
                1. interface keyword is bould tightly into name of the interface
                2. Interface-Body must be separated by at least one new line character at both beginning and end
                3. endinterface keyword must be separated from anything else.
        
        9.1.2 Variables
            See 8.2 - Variable Definition
        
        9.1.3 Methods
            opt:(Visibility-Qualifier) opt:(Comp-Qualifier) opt:(Const-Qualifier) opt:(Staticity-Qualifier)
            method opt:(operator) name takes opt:(arguments) returns opt:(Const-Qualifier) return_type opt:(defaults (impl_value))
            
            Example:
                method m takes integer i, integer a returns real
                
                method q takes integer i, integer c returns integer defaults (i * c + 5)
            
            Arguments are of following form:
                opt:(Comp-Qualifier) opt:(Const-Qualifier) type_name variable_name opt:(= Initial_value) opt:(, arg2...)
                
            Visibility-Qualifier is ignored if provided.
            
            Deprecated, nor inline keywords can be specified for methods declared inside interface, or any children of interface
            overriding given method.
            
            Method declared inside interface follows the same rules as method declared inside struct(see 8.3 - Methods).
            
            Methods declared inside interface do not need to provide stub keyword, and it will be rejected with syntax error if
            one is provided, because they are implicitly overridable. Overridable methods in children of interface can be declared
            as stub but are not needed to be.
            
            Methods declared inside interface can also default to some calculable value or
            returned value from function call that is implicitly convertible into return_type. This expression must be bracket-enclosed.
            If they do so, children of given interface do not need to provide implementation of given methods, and if none is provided
            and call for object of any children is attempted, the defaulted value is returned.
            
            Methods declared inside interface can also provide implicit values for arguments, which mark default values for arguments.
            Implicit values must follow the same rules as implicit values for functions(See 4.2.1.1 - Function argument's implicit values).
            
			Methods declared inside interface may not be templated.
			
            Children types that derive given interface can declare such methods with different implicit values as well as different
            number of implicit arguments, but there can only be at most as many arguments with implicit value as in the declaration
            inside interface.
            
            Every method must have such unique name, that there is no other Name-Referable vJass Construct with the same name visible
			to given method.
            
            9.1.3.1 White spaces
                opt:(Visibility-Qualifier) opt:(Comp-Qualifier) opt:(Const-Qualifier) opt:(Staticity-Qualifier)
                method opt:(operator) name takes opt:(arguments) returns opt:(Const-Qualifier) return_type opt:(defaults (impl_value))
                
                1. Comp-Qualifier and Const-Qualifier are bound tightly into each other if provided, and bound loosely to preceding and following Syntactic Unit.
                2. Staticity-Qualifier is bound loosely to both preceding and following Syntactic Unit.
                3. operator keyword, if provided is bound tightly into method keyword.
                4. Preceding keyword is bound tightly to the name of method, which is bound tightly to the takes keyword.
                5. all arguments are bound loosely to each other with special rules(see 4.2.1.3 - Argument's White spaces).
                6. returns keyword is bound loosely to the last argument specified in argument's list or to nothing keyword otherwise.
                7. Return type with its Qualifiers is bound loosely to returns keyword.
                8. If Const-Qualifier is specified for return type, it is bound tightly with the return type.
                9. Keyword defaults, if provided, is bound tightly into preceeding Syntactic Unit.
                10. impl_value is bound tightly into defaults and every sub-expression inside impl_value follows
                    its own rules for white spaceing.
                11. Every other Syntactic Unit is bound tightly to each other.
                
            9.1.3.2 Argument's White spaces                    
                opt:(Const-Qualifier) type_name1 variable_name1 opt:(= Initial_value)
                opt:(, opt: opt:Const-Qualifier type_name2 variable_name2 ...)
                
                1. If Const-Qualifier is specified, it is bound tightly to name of argument's type.
                2. Argument's name is bound tightly to name of argument's type.
                3. Initial_value, as well as = is bound tightly into variable_name, if provided.
                4. Comma following argument N, if specified is bound tightly into argument's name.
                5. Every independent argument is bound loosely to each other.

10. Free standing methods
    Free standing methods declare struct-like syntax for Basic and Non-Basic types.
    
    10.1 Syntax
        opt:(deprecated) opt:(inline)
        opt:(Visibility-Qualifier) opt:(Comp-Qualifier) opt:(Const-Qualifier)
        method Type.method_name takes opt:(arguments) returns opt:(Const-Qualifier) return_type
            Free-StandingMethod-Body
        endmethod
        
        Example:
            private method unit.kill takes string toPrint returns boolean
                local boolean b = KillUnit(this)
                if b then
                    call BJDebugMsg(toPrint)
                endif
                return b
            endmethod
        
        Every free standing method must have such unique name that there is no other private free standing method with the same name
        for the same type in the same Scope.
		
        this variable always stores the object for running instance(for instance inside free standing method for unit, this will refer
        to the unit that the method was called on).
        
        Free standing methods may not be declared inside structs.
        
        Rules other than mentioned above as well as white spacing of Free standing methods are the same as member methods(See 8.3 - Method).
        
        Free standing method can not be declared as static(they are implicitly static), cannot be declared as stub or override
        and cannot be operator.
        
        10.1.1 White spaces
            opt:(deprecated) opt:(inline)
            opt:(Visibility-Qualifier) opt:(Comp-Qualifier) opt:(Const-Qualifier)
            method Type.method_name takes opt:(arguments) returns opt:(Const-Qualifier) return_type
                Free-StandingMethod-Body
            endmethod
            
            1. Free-standing methods follow the exact same rules of white spacing as normal methods do, but Type, "." and method_name
               are all bound to each other tightly.

11. Module
    Module is a piece of code that can be implemented inside struct or another module.
    Module can contain any lines of code that are also valid inside struct and any number of them.
    
    11.1 Syntax
        11.1.1 Definition
            opt:(Visibility-Qualifier) module module_name
                Module-Body
            endmodule
            
            Visibility-Qualifier is only applicable if module is defined inside Library(see 7. - Library) or Scope(see 6. - Scope).
            
            Modules can also contain parts of methods and other methods below them, effectively chopping parts of methods
            away.
            
            Deprecated feature: Modules can also contain allocate and deallocate methods, which will override generated methods.
            New rule(applied at future version): Modules can not declare allocate or deallocate methods.
            
            onInit method declared within module will not override onInit method from inside struct that implements given module, but
            will instead run according to 1.14 - Initializer rules.
            
            Every module must have such unique name that there exists no other private Name-Referable Construct.
            
            11.1.1.1 White spaces
                opt:(Visibility-Qualifier) module module_name
                    Module-Body
                endmodule
                
                1. Visibility-Qualifier, if provided, is bound tightly into 'module' keyword.
                2. module keyword is bound tightly into module_name.
                3. endmodule keyword must be separated from anything else.
            
        11.1.2 Usage
            implement opt:(optional) myModule
            
            Example:
                module M
                    static method fromM takes nothing returns nothing
                        call BJDebugMsg("5")
                    endmethod
                endmodule
                
                struct Q
                    implement M
                endstruct
                
                struct W
                    implement M
                endstruct

            Only structs can implement module.
            
            When module is implemented, its code is unfolded into the struct, allowing sets and calls, or even ending blocks to be inside module.
            If module being implemented has method with same signature as implementing struct, an error is issued.
            
            If optional keyword is provided and module doesn't exist, no compiler error is issued.
            
            11.1.2.1 White spaces
                implement opt:(optional) myModule
                
                1. The whole expression must be placed on a separate line.
                2. Every Syntactic Unit is bound tightly into every other Syntactic Unit.
        
12. Allocator
    Allocator is special module with different keyword for definition as well as usage.
    
    12.1 Syntax
        12.1.1 Definition
            allocator alloc_name
                Allocator-Body
            endallocator
            
            Example:
                allocator MyAllocator
                    static method allocate takes nothing returns thistype
                        return 1
                    endmethod
                endallocator
            
            Allocators can only contain 2 methods:
                - static method allocate takes opt:(arguments) returns thistype
                - method deallocate takes nothing returns nothing
            
            Allocator can additionally only contain declaration of variables used inside either allocate or deallocate methods.
            Both methods must be provided inside allocator, otherwise allocator is malformed and cannot be
            declared as used(See 11.1.2 - Usage). If such allocator is used, compiler error is issued.
            
            Every allocator must have such unique name that there is no other private allocator with the same name in the same scope
            as well as any other public allocator in the Global Scope.
            
            12.1.1.1 White spaces
                allocator alloc_name
                    Allocator-Body
                endallocator
                
                1. Every Syntactic Unit is bound tightly to every other Syntactic Unit.
                2. endallocator keyword must be placed on separate line, separated from any code.
        
        12.1.2 Usage
            using opt:(optional) alloc_name
            
            Example:
                allocator A
                    ...
                endallocator
                
                allocator B
                    ...
                endallocator
                
                struct Q
                    using B
                    using optional A
                endstruct
            
            Struct must declare usage of allocator before first method, otherwise it is ignored.
            If allocator is used, but is not present in the script and 'optional' keyword is not provided, an error is issued.
            
            One struct can declare usage of multiple allocators, and the last existing optional or existing non-optional allocator
            declared as used will be used.
            
            Example:
                struct S
                    using allocator1
                    using optional allocator2
                endstruct
                
                Allocator1 will be used if allocator2 is not present on map. Otherwise Allocator2 will be used.
            
            12.1.2.1 White spaces
                using opt:(optional) alloc_name
                
                1. Every Syntactic Unit is bound tightly to every other Syntactic Unit.
                2. The whole line must be placed on separate line, separated from any other code.

13. Alias
    Alias masks type name or variable name so that it can be used as another type name or variable name, respectively.
    
    13.1 Syntax
        alias existing_type_variable new_type_variable
        
        Example:
            alias integer int
            alias MyLibrary.AwesomeType T
			
			globals
				integer DDS_Damage_Event
			endglobals
			
			alias DDS_Damage_Event dEvent
			
			set dEvent++
            
        Alias must always be used inside vJass construct that allows Visibility-Qualifiers.
        Alias never aliases type or variable globally, only inside scope it is declared in.
        
        13.1.1 White spaces
            alias existing_type_variable new_type_variable
            
            1. Every Syntactic Unit is bound tightly to every other Syntactic Unit.
            2. The whole line must be placed on separate line, separated from any other code.

14. Hook
    Hook allows to run user-defined functions when other user-defined or Blizzard-defined functions are called.
    
    14.1 Syntax
        hook opt:(optional) opt:(hookmode) hooked_func to_call opt:(priority)
        
        Example:
            hook optional after RemoveUnit onRemove
            hook before RemoveUnit onRemoveB priority=54
            hook RemoveUnit onRemoveC
            
        hooked_func represents function that should be hooked, e.g. when it is called, the other one should be executed according
        to hookmode.
        to_call represents function that is called when invocation of hooked_func is attempted in any way.
        to_call must have the same arguments as the hooked_func, and can return any value.
        to_call can be function or static method with any Visibility-Qualifier and with any Const-Qualifier.
        hooked_func must be visible at the point of hooking, can be of any Const-Qualifier, and must be function or static method.
        
        If optional keyword is provided and hooked_func does not exist, no error is issued, otherwise compilation error is issued.
        
        hookmode is special variable representing when to call the caller. If none is provided, before is implicitly assumed.
        Available hookmodes: before, after.
        
        before hookmode will result in call to the caller before the actual call to hooked function.
        after hookmode will result in call to the caller after the actual call to hooked function.
        
        With before hookmode, the caller has no way to prevent call to the hooked function, other than forcefully stopping currently
        executing virtual thread.
		
		Optionally a priority can be provided, for priority explanation, see 1.17 - Priorities.
        
        13.1.1 White spaces
            hook opt:(optional) opt:(hookmode) hooked_func to_call opt:(priority)
            
            1. Every Syntactic Unit is bound tightly to every other Syntactic Unit.
            2. The whole line must be placed on separate line, separated from any other code.
			3. Priority must follow its separate rules, but priority is bound tightly into to_call Callable object.

15. Textmacro
    Textmacros are compile-time text expanders, which take code and expand it with some optional changes to it at places in map script.
    
    15.1 Syntax
        15.1.1 Definition
            opt:(Visibility-Qualifier) textmacro opt:(takes argument_list)
                Textmacro-Body
            endtextmacro
        
            Example:
                textmacro MyMacro takes A, B, C, D, E
                    $A$ function $B$ takes $C$ returns $D$
                        return $E$
                    endfunction
                endtextmacro
            
            Arguments are of following form:
                ARG1, ARG2, ARG3, ARG4...
            
            Visibility-Qualifier is only applicable when textmacro is declared within vJass construct allowing Visibility-Qualifiers.

            If no arguments are passed, takes keyword must be omitted.
            
            All arguments, when used, must be enclosed in $ signs, marking the actual usage of given argument.
            Arguments of textmacro are typeless.
            
            Textmacro must have such unique name that there is no other private textmacro with the same name in the same scope.
            
            15.1.1.1 White spaces
                opt:(Visibility-Qualifier) textmacro name opt:(takes argument_list)
                    Textmacro-Body
                endtextmacro
                
                1. If Visibility-Qualifier is provided, it is bound tightly into 'textmacro' keyword.
                2. textmacro keyword is bound tightly into name.
                3. if arguments are provided, they are bound tightly into each other as well as takes keyword.
                   Additionally, takes keyword is bound tightly into the name.
            
        15.1.2 Usage
            runtextmacro opt:(optional) name( opt:(args) )
            
            Example:
                runtextmacro optional MyMacro("First", "Second")
            
            If optional keyword is provided and given textmacro does not exist, nothing happens, otherwise compilation error is issued.
            If textmacro without arguments is ran, empty parenthesis pair is inserter.
            
            All textmacros arguments must be compile-time string values.
            
            15.2.1 White spaces 
                runtextmacro opt:(optional) name( opt:(args) )
                
                1. Every Syntactic Unit is bound tightly into each other.
                2. The whole line must be placed separated from any other code.

16. Extendor
	Extendor is, similarly to textmacro, compile-time text expander, but rather than expanding one fixed body into multiple places,
	extendor can have multiple bodies expanded at multiple places.
	
	16.1 Syntax
		16.1.1 Defining
			extendor Name opt:(priority) opt:(RunMode Mode_Extendor_Name) opt:(takes Argument_List)
				Extendor-Body
			endextendor
			
			Arguments are of following form:
				ARG1, ARG2, ARG3...
			
			Example:
				extendor X priority=50 takes A, B, C
					//CODE A
				endextendor
				
				extendor Y priority=-1 After X takes A, B
					//CODE B
				endextendor
				
				extendor Z After X takes A
					//CODE C
				endextendor
			
			Every extendor can have any number of bodies, and every body can take different, and any number of arguments, and can have
			its own priority.
			
			If one extendor's definition specifies RunMode, all definitions of the same extendor must also provide the same RunMode, or
			Compilation error is issued.
			
			Extendor can contain any number of any vJass Constructs other than another Extendor.
			
			RunMode is special mode, specifying when should the extendor be evaluated.
			Possible values for RunMode: AfterEarly, After, AfterLate, BeforeEarly, Before, BeforeLate,.
			RunMode is case sensitive.
			
			RunModes explained:
				AfterEarly - Runs after Mode_Extendor_Name has been instructed to run, and before any After extendors for given extendor.
				After - Runs after Mode_Extendor_Name has been instructed to run, before AfterLate, and after AfterEarly extendors for given extendor.
				AfterLate - Runs after Mode_Extendor_Name has been instructed to run and after all AfterEarly and After extendors for given extendor.
				
				BeforeX - The same rules as for After, but they are executed before the Mode_Extendor_Name, instead of after.
			
			If no RunMode is provided, "Global" value is assumed, meaning that the extendor is not attached to any other's extendor execution.

			For Priority, See 1.17 - Priorities.
			
			If two definitions of the same extendor have same priority and same RunMode, they will be evaluated in order of appearance to the parser.
			
			Any and all strings that are same as any of the arguments which are surrounded by at least one non alphanumeric character with
			the passed argument will get replaced with the value of given argument.
			
			16.1.1.1 White spaces
				extendor Name opt:(priority) opt:(RunMode Mode_Extendor_Name) opt:(takes Argument_List)
					Extendor-Body
				endextendor
				
				1. Every Syntactic Unit before Extendor-Body is bound tightly into each other.
				2. Extendor-Body must start at separate line from extendor's definition.
				3. endextendor must be placed on separate line.
			
		16.1.2 Usage
			runextendor Name opt:[(args)]
			
			Example:
				runextendor X("A", "B", "C", "D")
				runextendor X("A", "B")
			
			One extendor can be ran any number of times.
			If user attempts to run extendor that does not exist, nothing happens, and compilation continues.
			
			Every ran extendor can provide any number of arguments, and if any body of ran extendor require more arguments, they are implicitly
			generated as empty, and if extendor is ran with more arguments, than the rest of arguments are ignored.
			
			When extendor is run, it will be evaluated regardless if it has RunMode specified or not, and all extendors that have RunMode of this
			extendor will also be evaluated.
			
			All extendor's arguments can be treated as compile-time and therefore be used in compile-time environment and expanded argument can
			only be used in compile-time environment if it evaluates into compile-time value.
		
			16.1.2.1 White spaces
				runextendor Name opt:[(args)]
				
				1. runextendor is bound tightly into name.
				2. If arguments are provided, the Name is bound tightly into the starting (, and all arguments are bound loosely to each other,
				   first argument is bound tightly into the opening parenthesis, last argument is bound tightly into closing parenthesis and
				   each argument is bound tightly to following comma, if any.

17. External, externalblock
    External and externalblock let JassHelper run external programs according to the path with name of the program with given
    input.
    
    17.1 Syntax
        17.1.1 external
            external opt:(runmode) program_name program_command_line_input
            
            Example:
                external ObjectMerger "" w3a Amls A000 anam "Fire"
                external before ObjectMerger "" w3a Amls A000 anam "Fire"
            
            program_name must be executable program and must accept command line options program_command_line_input.
            If given program does not exist, a compiler error will be issued.
            
            program_name's console output will be print to the console and compilation output file.
            
            Runmode specifies when should the program run. Available modes are: 'before', 'after'.
            
            before runmode will execute given external program with its input before actual map script compilation begins.
            after runmode will execute given external program after JassHelper finished compiling the map script.
            
            The only implicitly passed argument into the external program is the map name and every other argument must be
            specified in the script.
            A special variable is provided which can be passed into external program as map name, in which case the map name is not
            passed as implicit. This variable is $MAPNAME$.
        
            17.1.1.1 White spaces
                external opt:(runmode) program_name program_command_line_input
                
                1. Every Syntactic Unit is bound tightly into each other.
                2. The whole expression must be placed on separate line.
        
        17.1.2 externalblock
            externalblock opt:(runmode) opt:(extension=EXT) program_name program_command_line_input
                ExternalBlock-Body
            endexternalblock
            
            Example:
                externalblock extension=lua ObjectMerger "" $FILENAME$
                    //lua script for ObjectMerger
                endexternalblock
            
            program_name must be executable program and must accept command line options program_command_line_input.
            If given program does not exist, a compiler error will be issued.
            
            program_name's console output will be print to the console and compilation output file.
            
            Runmode specifies when should the program run. Available modes are: 'before', 'after'.
            
            before runmode will execute given external program with its input before actual map script compilation begins.
            after runmode will execute given external program after JassHelper finished compiling the map script.
            
            Extension defines what extension should be the file saved with. For instance, if extension is set to txt, the file will be
            saved as Temp_File.txt.
            
            The only implicitly passed argument into the external program is the map name and every other argument must be
            specified in the script.
            If a temporary file made by externalblock is to be used, a $FILENAME$ shall be used as part of program_command_line_input.
            A special variable is provided which can be passed into external program as map name, in which case the map name is not
            passed as implicit. This variable is $MAPNAME$.
            
            All Jass comments are removed from ExternalBlock-Body before it is passed into the external program.
            
            17.1.2.1 White spaces
                externalblock opt:(runmode) opt:(extension=EXT) program_name program_command_line_input
                    ExternalBlock-Body
                endexternalblock
                
                1. externalblock keyword is bound tightly into the following Syntactic Unit
                2. runmode as well as extension, if provided, are bound tightly into following and preceding Syntactic Unit
                3. program_name is bound tightly into preceding Syntactic Unit and bound loosely into program_command_line_input.
                4. endexternalblock keyword must be placed on separate line from any other code.

18. Template
    Templates provide compile-time type deduction powered by ad-hoc polymorphism.
    
    18.1 Syntax
        18.1.1 Definition
            template <opt:(Type type_name opt:(, Type type_name...))> opt:(requires Constraints_List)
            permitted_construct
            
            Example:
                template<type A> requires A == integer
                function MyFunc takes A a returns integer
                    return (integer)a
                endfunction
                
                template<type T>
                method operator T
                    return (T)this.myUnit
                endmethod
                
                template <type T> requires !Compiler.exists(method operator T<integer>(T<real>))
                function f takes T<integer> t_inst returns T<real>
                    return (T<real>)t_inst
                endfunction
                
                template <type T, integer Q>
                function f takes T t returns integer
                    return t.method(Q)
                endfunction
            
			Requires list must be provided before the start of templated construct's definition.
			For Constraints, See 18.5 - Constraints.
			
            Only functions, methods, structs, aliases and concepts can be templated.
            
            Template can have any number of arguments, and all arguments must be either of type or some specified type.
            
            If type is mentioned, the parameter is of undefined type and the template will accept any valid type in given slot,
            if some given type is provided, the template expects compiletime value of given type as argument at that place.
            
            Arguments can have implicit values(See 18.4 - Template argument's implicit value), but only in such way that
            if Nth argument is implicit than all arguments to the right of Nth argument must also have implicit values.
            
            Templates are always instantiated from inside out, meaning that A<B<C<D>>> will first instantiate C<D>, then it will instantiate B<C<D>> and finally A<B<C<D>>>.
            
            Templates are only instantiated when explicitly or implicitly required.
            
            Templates can have variadic number of arguments(See 18.3 - Variadic Templates) or can provide
            partial specialization(See 18.2 - Partial Specialization).
            
            One vJass Construct can also be templated with multiple templates with different combination or number of arguments.
            
            Templated vJass Constructs can be used without specializing explicitly the template arguments if they are deducible.
            Only template arguments used in function's argument list are deducible. Return types for functions, in-function variables using
            templated type or structs must have explicitly stated template arguments.
            
            If template argument is deduced from null, the argument is of type handle.
            
            18.1.1.1 White spaces
                template <opt:(type type_name opt:(, type type_name...))> opt:(requires Constraints_List)
                permitted_construct

                Arguments are of following type:
                    Arg_type Arg_name, Arg2_type Arg2_name, ...
                
                1. template keyword is bound tightly into following <.
                2. < is bound tightly into following Syntactic Unit.
                3. If any template arguments are specified, the first one is bound tightly into preceding Syntactic Unit, the last one
                   is bound tightly into the following Syntactic Unit, the argument's type is bound tightly into the argument's name,
                   the argument's name is bound tightly into following comma and each argument is bound loosely to each other.
                4. requires, if provided, is bound loosely to preceding and following Syntactic Unit.
                5. The Constraints_List after requires as well as templated vJass Construct must follow its own rules and white spacing rules.
        
        18.1.2 Usage
            TypeName < template_args > ...
            
            Example:
                local List<integer> l = List<integer>()
                call l.something()
                call l.templated_something<integer, real, real>()
                
                call List<integer>.static_something()
                call List<integer>.static_templated_something<integer, real, real>()
            
            TypeName must be a valid type name and must be templatable.
            
            templated_args must be of same types as in definition.
            
            After template instantiation, either nothing in regards to the instantiation can appear, or ".", or ( can appear.
            
            18.1.2.1 White spaces
                TypeName < template_args > ...
                
                1. Every Syntactic Unit is bound tightly into each other.
        
    18.2 Specialized Templates
        Specialized templates are such templates that have no arguments and provide specialized body for given vJass Construct with given
        signature. Specialized template can only be provided for vJass Construct that is already templetized.
        
        18.2.1 Syntax
            template <> opt:(requires Constraint_List)
            permitted_construct<specified_args>
            
            Example:
                template <type A, type B>
                functon f takes A a, B b returns nothing
                    call a.something(b)
                endfunction
                
                template<>
                function f<integer, real> takes integer i, real ff returns nothing
                    call someFunc(i, ff)
                endfunction
                
                template <>
                function f<Matrix, real> takes Matrix m, real ff returns nothing
                    call a.somethingDifferent(ff)
                endfunction
                
                template <type T>
                struct S
                    T t
                    static method myM takes T q returns thistype
                        local thistype this = .allocate()
                        set t = q
                        return this
                    endmethod
                endstruct
                
                template <>
                struct S<integer>
                    integer t
                    static method myM takes integer q returns thistype
                        local thistype this = allocate()
                        set t = q
                        call print("set t to " + (integer)q)
                        return this
                    endmethod
                endstruct
                
                template <integer I>
                struct Q
                    static integer i = I * Q<I-1>.i
                endstruct
                
                template <>
                struct Q<1>
                    static integer i = 1
                endstruct
                
                call BJDebugMsg((string)Q<10>.i)        //prints 3628800
            
            Resulting vJass Construct in Specialized template must not have a difference in signature other than type mismatching.
            
            When vJass Construct is templated using specialized template, the template arguments must be provided explicitly in <> block
            after the name of vJass Construct.
            
            When vJass Construct is templated using specialized template, it must have unique arguments compared to other specialized templates
            of given vJass Construct.
            
            Specialized template can only be used if the original template has at least one argument of unspecified type, and can only
            override unspesified types. All specified types must stay the same.
            
            Constructor or destructor of struct cannot be templated. If struct's constructor or destructor are templated, a compiler error is issued.
            
            18.2.1.1 White spaces
                template <> opt:(requires Constraint_List)
                Permitted_construct_name<specified_args>
                    Permitted_construct_Body
                Permitted_construct_end
                
                Arguments are of following type:
                    Arg_type Arg_name, Arg2_type Arg2_name, ...
                
                1. template keyword is bound tightly into following <.
                2. < is bound tightly into >.
                3. requires Constraint_List, if provided is bound tightly into preceding Syntactic Unit and
				   loosely into the following Syntactic Unit.
                4. < after Permitted_construct_name is bound tightly into it as well as first argument of specialized template.
                5. > is bound tightly into last argument of specialized template and requires that Permitted_construct_Body is placed
                   on different line.
                6. Argument's type is bound tightly into the Argument's name and following comma, if any, and is bound loosely to the next
                   argument of specialized template.
                7. Permitted_construct must also follow its respective rules.

    18.3 Variadic Templates
        Variadic template is such template that has undefined number of arguments.
        
		18.3.1 sizeof operator
			The sizeof operator returns the number of arguments inside variadic template argument as compiletime integer.
			
			Example:
				template <type... C>
				function number takes C c returns compiletime integer
					return sizeof(c)
				endfunction
			
			Implementation in vJass:
			
				template <type C>
				struct templateDetailImpl
					compiletime integer size = 1
				endstruct
				
				template <type A, type... B>
				struct templateDetailImpl
					compiletime integer size = 1 + templateDetailImpl<B>.size
				endstruct
				
				template <type... C> compiletime function sizeof takes C c returns integer
					return templateDetailImpl<C>.size
				endfunction
			
        18.3.2 Syntax
            template <type A, type B, type... C>
            perimtted_construct
            
            Example:
                template <type A, type... B>
                function f takes A a, B b returns HashStorage
                    compiletime local integer BSize = sizeof(B)
                    local HashStorage h = HashStorage()
                    compiletime local integer iter = 0
                    loop
                        call h.add(b[iter])
                        //optionally:
                        call h.add<B[iter]>(b[iter])
                        exitwhen iter == BSize - 1
                        set iter++
                    endloop
                    return h
                endfunction
            
                f(5, 3, 2.00, "my string") -> h now stores [5, 3, 2.00, "my string"]
            
            One template can only have one deducible variadic template or any number of explicitly deducible variadic templates.
            Example:
                template <type... A, type... B>
                function f takes A a, B b returns nothing
                endfunction
                
                is not valid because compiler does not know where does A end and where does B start, whereas
                
                template<type C, type... A, type... B>
                function f takes C<A> q, B b returns nothing
                endfunction
                
                is valid, since C is the outer-most type passed into the function as first argument, and its separate template type
                is deduced to be A, and B is deduced as the rest of arguments passed into the function.
            
            Variadic template can also have 0 arguments.
            
            Basic array subscript operator( [] ) can be used to get type at given position out of variadic template pack.
            The same applies for variables in functions, if variable is of variadic template pack type.
			The passed in value must be compiletime deducible.
            
            No variable other than function argument can be of variadic template pack type.
            Variadic templates can be sepcialized as any other template.
            
            18.3.2.1 White spaces
                template <type... A, opt:(type opt:(...) name1), opt:(type opt:(...) name2)...>
                perimtted_construct
                
                1. ... is bound tightly into type keyword as well as following name of variadic template argument.
                2. the same rules as for normal template apply.
    
    18.4 Template argument's implicit value
        Normal template arguments can default into some value or type but only in such way that if certain template argument defaults to
        some value, than all template arguments to the right of it also must provide implicit value.
        
        18.4.1 Syntax
            Example:
                template <type A, type B, type C = B<A>>
                function q takes C c, A a, B b returns nothing
                endfunction
                
                template <type A, integer B = 5, type C = integer>
                struct S
                endstruct
            
            18.4.1.1 White spaces
                1. The same rules for default values apply as for function's argument
                   default values(See 4.2.1.1 - Function argument's implicit values).
                2. For the rest, same rules apply as for normal template.
	
	18.5 Constraints
		Templates depending on constraints are only generated when all Constraints evaluate to true.
		
		One template can have any number of comma separated constraints.
		
		Constraints can be either Concept(See 18.5.1 - Concept), or a compile-time condition, or a special operator call(See 2.6.4 - Comparisons).
		
		Example:
			template <type T> requires Arithmetic<T>, T != Table, T extends MyAwesomeType and !(T extends MyAnotherAwesomeType),
					Compiler.isParentOf(T, SomeType) and Compiler.isSame(T, T)
				function f takes T t returns T
					return t
				endfunction
		
		18.5.1 Concept
			18.5.1.1 Syntax
				concept Name
					Concept-Body
				endconcept
				
				Example:
					template <type T>
					concept Arithmetic
						method T.operator+ takes T rhs returns T
						method T.operator- takes T rhs returns T
						method T.operator* takes T rhs returns T
						method T.operator/ takes T rhs returns T
						//constructor takes T
						//destructor takes T
						//static method T.met_hod takes T something returns nothing
						//stub method T.m ...
						//function add takes T a, T b returns T
					endconcept
					
					concept Another requires integer != real, Compiler.isChildOf(unit, handle)
						method MyStruct.myMethod takes nothing returns nothing
					endconcept
					
					concept General requires Another
						function SomeFunction takes integer something returns integer
					endconcept
				
				Concepts are compile-time evaluators.
				
				Concepts can be templated, and can put following requirements on any type visible to the concept:
					1. existence of method with given name, arguments and return type
					2. existence of function with given name, arguments and return type
				
				Concept can only become Constraint after it has been fully defined.
				Concept itself can have Constraints.
				
				If function or method with given name, signature and return type does not exist, the concept returns false.
				
				18.5.1.1.1 White spaces
					concept Name
						Concept-Body
					endconcept
					
					1. concept and Name are bound tightly.
					2. Concept-Body must start at separate line.
					3. endconcept must end at separate line.

19. Auto
    Auto keyword allows compiler to deduce type of variable according to the initial assignment.
    
    19.1 Syntax
        auto var_name = var_initial_value
        
        Example:
            local auto v = Location(5., 5.)
            
            globals
                private auto var = StringLength("")
            endglobals
            
            temporary auto q = CreateGroup()

        Global, Local and temporary variables may be declared as auto.
        
        Every variable declared with automatic type must have initial value, or the type is ineducable.
        
        19.1.1 White spaces
            auto var_name = var_initial_name
            
            1. Keyword auto is bound tightly into var_name.
            2. Other Syntactic Units must follow same rules as with assignment to normal variables(See 3. - Variable).

20. Import
    Import allows JassHelper to load and parse Jass files from external sources.
    External sources can be local hard-drive, or file placed on internet.
    
    20.1 Syntax
        import "file_to_import"
        
        Example:
            import "http://raw.github.com/some_repository/some_jass_file.j"
            import "../../scripts/My_Awesome_Jass_Script.j"
        
        If file_to_import is invalid file, a compiler error is issued, and compilation stops.
        
        If file_to_import starts with "http://", "//" or "www.", Compiler attempts to download given file from internet.
		If such file has already been downloaded from the internet before, and it has not been changed since, the cached version is used instead.
		
        Otherwise, a open file request is sent to Operating System with provided path.
        
        Path can be relative or absolute.
        
        Imported file must be fully valid Jass or vJass file with any of above mentioned features included.
        Otherwise, compiler error is issued.
        
        20.1.1 White spaces
            import "file_to_import"
            
            1. All Syntactic Units are bound to each other tightly.

21. JassHelper command line arguments
    JassHelper provides multiple command line arguments for more flexible compilation:
    
    commonj=path
        Specifies path to common.j file. If no path is provided, a folder where JassHelper is placed is used.
    
    blizzj=path
        Specifies path to blizzard.j file. If no path is provided, a folder where JassHelper is placed is used.
    
    commonai=path
        Specifies path to commonai.j file. If no path is provided, a folder where JassHelper is placed is used.
    
    map=path
        Path to map archive which should be compiled.
        If no such map archive exists, compiler issues error.
    
    script=path
        Path to script which should be parsed.
        If no such script exists, compiler issues error.
        Please note that if map flag is provided, script flag is omitted.
    
    mapout=path
        A path to map archive that the compiled script should be outputted to.
        If no such map archive exists, a one will be created.
        If map flag is provided, mapout flag is omitted and the script will be outputted to the same map archive.
    
    scriptout=path
        A path to Jass script that the compiled script should be outputted to.
        If no such script exists, a one will be created.
        Possible path option is also 'script', which will output the compiled script into the same script file.
    
    /OX
        Specifies optimization level.
        Possible values:
                        0 - no optimizations should be run
                        1 - full optimizations
        
        If flag is not provided, /O1 is assumed.
    
    debug=on, debug=off
        Specifies whether map script should be compiled with debug mode or not.
        If flag is not provided, debug=off is assumed.
    
    jhdebug=on, jhdebug=off,
        Specifies whether JassHelper should run in debug mode or not.
        
        When JassHelper runs in debug mode, it will forcefully create backups of map archive or script it is compiling
        before compilation starts, and will output debug messages when certain conditions are met.
        
        If flag is not provided, jhdebug=off is assumed.
    
    -help
        prints help message.
    
    jassonly=X
        Specifies whether JassHelper should compile map with vJass allowed or not.
        Possible values:
                        0 - compile as vJass script
                        1 - compile as Jass only
        
        If flag is not provided, jassonly=0 is assumed.
        
        Note: Compiler methods can be run even when jassonly=1 is provided.
    
    forcebackup=X
        Specifies whether a forced backup of compiling map/script and resulting map/script(if already exists) should be created.
        Possible values:
                        false - Do not forcefully back up
                        true - Do forcefully back up
        
        If flag is not provided, forcebackup=true is assumed.
    
    networking=X
        Specifies whether network access should be granted to JassHelper.
        Possible values:
                        false - Do not allow JassHelper to connect to internet
                        true - Do allow JassHelper to connect to internet
        
        If flag is not provided, networking=true is assumed.
    
    maxinlinesize=X
        Specifies at how many bytes should function no longer be inlined.
        Possible values: If number lower than 0, or number bigger than 2,147,483,647 is used, maxinlinesize is ignored.
        Numbers should be passed without ",", otherwise they are considered invalid.
        
        If flag is not provided, maxinlinsize=50 is assumed.
    
    configfile=path
        Specifies where should configuration file be looked for at.
        If no such configuration file exists, a configuration file from folder where JassHelper is placed will be loaded.
        If that configuration file does not exist either, this flag is omitted.
        
        If flag is not provided, a automatic path will be assumed which is equal to path JassHelper sits in.
    
    templatemaxdepth=X
        Specifies what is the maximum depth template can try to instantiate certain vJass Construct(instantiation within instantiation).
        Possible values: If number lower than 1, or number bigger than 1000 is used, templatemaxdepth is ignored.
        
        If flag is not provided, templatemaxdepth=300 is assumed.
    
    -version
        Prints current version of JassHelper as well as creator's name.
    
    -credits
        Prints list of contributors to JassHelper.
    
    -contact
        Prints contact information.
    
    -about
        Alias for -version -credits -contact.
        
    -encryptmethod=X
        Specifies what encryption method for encrypted local strings should be used.
        Possible values: Nan, None, No, BAE, BSE, ME.
        
        Values explanation:
            Nan, None, No - no encryption shall be used, even if user required encrypted strings.
            
            BAE - Basic addition encryption
                All required strings are encrypted in such way that their letters get changed ASCII values, and are decrypted when use is requested.
            
            BSE - Basic shuffle encryption
                All required strings are encrypted in such way that their letters get changed positions, and are decrypted when use is requested.
            
            ME - Mixed Encryption
                All required strings are encrypted in such way that their letters get changed ASCII values as well as changed position, and
                are decrypted when use is requested.
        
        If flag is not provided, -encryptmethod=BAE is assumed.

22. Configuration file contents
    Configuration file can contain additional options for compiler, easing command line options.
    
    Configuration file should always start with [JH CONFIG FILE] and then options should follow.
    Available options in config file(not case-sensitive):
    
    LOOKUPPATHS="VAL1", "VAL2", ...
        Specifies lookup paths for relative paths passed in command line

23. Miscellaneous
    23.1 Function(method) weight on resolution
        When function is called, every version of given function is weighted and function with best weight is picked to be called.
        
        The weighting system works in following way:
            
            1. Function with the same signature requiring no casts has weight 0.
                1.1 If multiple functions with weight 0 for single call exist, a compiler error is issued.
            2. Function with the same number of arguments but requiring one or more arguments has weight 1.
                2.1 If multiple functions with weight 1 are found and none with weight 0, the function that requires
                    the least number of implicit conversions is picked.
                    If there are multiple functions with the same number of required implicit conversions and one of them is picked
                    to be the called function, a error is issued.
            3. Specialized template of function has weight of 2.
                3.1 If multiple specialized templates with the same number of arguments are found, they are decided with rules 1. and 2.
            4. Template function has weight 3.
                4.1 If after type deduction multiple functions fit the function call, the correct function to call is decided with rules 1. and 2.

    23.2 Encrypted
        Encrypted allows the JassHelper compiler to encrypt marked strings when using raw string data with certain algorithms.
        
        Be aware that while encryption has no performance impact, the decryption requires time linearly scaling with size of string,
        and may eat a lot of OPs, resulting in Op-heavy code crashing the running virtual thread because of decryption of strings.
        
        Use this only on strings you care about.
        
        23.2.1 Syntax
            local encrypted opt:[(Enc_Mode)] string opt:(array) string_name opt:(= Initial_value)
            
            Example:
                local encrypted string s = "My awesome" + " brutally encrypted string!"
                local encrypted(ME) string s = "Even better encryption!"
            
            String encryption only happens on raw strings, and happens at compile time, resulting in no performance impact of the code.
            Decryption must be done during runtime, resulting in possibly huge impact on Ops as a result of decryption.
            
            If encrypted does not provide Enc_Mode, a default Enc_mode is used from JassHelper.
            Possible Enc_Mode-s:
                Nan, No, None, BAE, BSE, ME.
            
            For explanation, check 21. - JassHelper command line arguments, -encryptmethod flag.
            
            23.2.1.1 White spaces
                local encrypted opt:[(Enc_Mode)] string opt:(array) string_name opt:(= Initial_value)
                
                1. encrypted is bound to local, as well as following Syntactic Unit tightly.
                2. (Enc_Mode), if provided, is bound to both preceding and following Syntactic Unit tightly.
                3. The remaining Syntactic Units follow 3.2.1.1 - White spaces